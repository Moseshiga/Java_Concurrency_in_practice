#TODO: бонусом сделать анализ всей concurrency библиотеки 

# То, что узнал в книге "Java Concurrency in practice" 

## Описание

Это мой заметки того, что я узнал изкниги "Java Concurrency in practice"

Если Вы автор и считаете, что данный конспект нарушает авторские права - прошу сообщить, я сделаю этот репозиторий
приватным.

# 1. Введение

# 2. Потокобезопастность

Написание потокобезопасного кода — это, по сути, управление доступом к состоянию и, в частности, 
к совместному (shared) мутируемому состоянию (mutable state).

При проектировании потокобезопасных классов хорошие объектно‑ориентированные технические решения: 
инкапсуляция, немутируемость и четкая спецификация инвариантов — будут вашими помощниками.

## 2.1. Что такое потокобезопастность 

Класс является потокобезопасным, если он ведет себя правильно во время доступа из многочисленных 
потоков, независимо от того, как выполнение этих потоков планируется или перемежается рабочей 
средой, и без дополнительной синхронизации или другой координации со стороны вызывающего кода.

Потокобезопасные классы инкапсулируют любую необходимую синхронизацию сами и не нуждаются в 
помощи клиента.

### 2.1.1. Пример: сервлет без поддержки внутреннего состояния
```java
@ThreadSafe
public class StatelessFactorizer implements Servlet {
    public void service(ServletRequest req, ServletResponse resp) {
      BigInteger i = extractFromRequest(req);
      BigInteger[] factors = factor(i);
      encodeIntoResponse(resp, factors);
    }
}
```

Объекты без поддержки внутреннего состояния всегда являются потокобезопасными

## 2.2. Атомарноть

Сервлет, подсчитывающий запросы без необходимой
синхронизации. Так делать не следует

```java
@NotThreadSafe
public class UnsafeCountingFactorizer implements Servlet {
  private long count = 0;
  public long getCount() { return count; }
  public void service(ServletRequest req, ServletResponse resp) {
      BigInteger i = extractFromRequest(req);
      BigInteger[] factors = factor(i);
      ++count;
      encodeIntoResponse(resp, factors);
    }
}
```

Хотя операция приращения **++count** имеет компактный синтаксис, она не является атомарной 
(atomic), то есть неделимой, а представляет собой последовательность из трех операций: «прочитать,
изменить, записать»

### 2.2.1. Состояние гонки

Наиболее распространенным типом состояния гонки является ситуация «проверить и затем 
действовать», где потенциально устаревшее наблюдение используется для принятия решения о том, что
делать дальше

### 2.2.2. Пример: состояние гонки в ленивой инициализации

```java
@NotThreadSafe
public class LazyInitRace {
  private ExpensiveObject instance = null;
  public ExpensiveObject getInstance() {
    if (instance == null)
      instance = new ExpensiveObject();
    return instance;
  }
}
```

Во время инициализации потока A, поток B может тоже начать инициализировать объект

### 2.2.3. Составные действия

Операции A и B являются атомарными, если, с точки зрения потока, выполняющего операцию A, 
операция B либо была целиком выполнена другим потоком, либо не выполнена даже частично.

Там, где это удобно, используйте существующие потокобезопасные объекты, такие как AtomicLong, 
для управления состоянием вашего класса. Возможные состояния существующих потокобезопасных 
объектов и их переходы в другие состояния легче поддерживать и проверять на потокобезопасность, 
нежели произвольные переменные состояния.

## 2.3. Блокировка

Сервлет, пытающийся кэшировать свой последний результат без адекватной атомарности. Так делать 
не следует

```java
@NotThreadSafe
public class UnsafeCachingFactorizer implements Servlet {
    private final AtomicReference<BigInteger> lastNumber
            = new AtomicReference<BigInteger>();
    private final AtomicReference<BigInteger[]> lastFactors
            = new AtomicReference<BigInteger[]>();
    public void service(ServletRequest req, ServletResponse resp) {
        BigInteger i = extractFromRequest(req);
        if (i.equals(lastNumber.get()))
            encodeIntoResponse(resp, lastFactors.get());
        else {
            BigInteger[] factors = factor(i);
            lastNumber.set(i);
            lastFactors.set(factors);
            encodeIntoResponse(resp, factors);
        }
    }
}
```

Когда в инварианте участвуют многочисленные переменные, поля не являются независимыми: значение 
одного ограничивает допустимые значения другого. Следовательно, при обновлении одного необходимо 
обновлять другие в той же атомарной операции.

Для сохранения непротиворечивости состояний обновляйте родственные переменные состояния в единой 
атомарной операции.

### 2.3.1. Внутренние замки

синхронизированный блок, состоящий из ссылки на объект-замок (lock), и блока кода, который будет 
им защищен.

```java
synchronized (lock) {
 // Обратиться к защищаемому замком совместному состоянию либо его
 // изменить
}
```

Внутренние замки в Java действуют как взаимоисключающие замки — мьютексы (mutual exclusion 
locks). Когда поток A пытается приобрести замок, которым владеет поток B, он должен ждать или 
блокировать продвижение до тех пор, пока B его не освободит. Если B не освободит замок никогда, 
то A будет ждать вечно.

Сервлет, кэширующий последний результат с неприемлемо
слабой конкурентностью. Так делать не следует

```java
ThreadSafe
public class SynchronizedFactorizer implements Servlet {
    @GuardedBy("this") private BigInteger lastNumber;
    @GuardedBy("this") private BigInteger[] lastFactors;
    public synchronized void service(ServletRequest req,
                                     ServletResponse resp) {
        BigInteger i = extractFromRequest(req);
        if (i.equals(lastNumber))
            encodeIntoResponse(resp, lastFactors);
        else {
            BigInteger[] factors = factor(i);
            lastNumber = i;
            lastFactors = factors;
            encodeIntoResponse(resp, factors);
        }
    }
}
```

### 2.3.2. Повторная входимость

Код, запертый взаимной блокировкой, так как внутренние замки не являются повторно входимыми

```java
public class Widget {
    public synchronized void doSomething() {
        ...
    }
}

public class LoggingWidget extends Widget {
    public synchronized void doSomething() {
        System.out.println(toString() + ": calling doSomething");
        super.doSomething();
    }
}
```

## 2.4. Защита состояния с помощью замков

Все обращения к мутируемой переменной состояния должны выполняться с удержанием одного и того же 
замка. Только тогда переменная защищена этим замком.

Каждая совместная мутируемая переменная должна быть защищена только одним замком. Дайте 
сопроводителям четкое понимание, какой это замок.

Для каждого инварианта, который включает более одной переменной, все переменные, участвующие в 
инварианте, должны быть защищены тем же замком.

## 2.5. Живучесть и производительность 


При реализации политики синхронизации не поддавайтесь искушению пожертвовать простотой (что 
может поставить безопасность под угрозу) ради производительности.

Избегайте удержания блокировки во время длительных вычислений или операций, таких как сетевой 
или консольный ввод‑вывод.

Эти два способа записи означают одно и то же:

```java
public void swap() {
   synchronized (this)
   {
       //...логика метода
   }
}

public synchronized void swap() {
    //...логика метода
}
```

Обновленный код, в котором кешируется последнее число и его делители с счетчиками для статистики

```java
@ThreadSafe
public class CachedFactorizer implements Servlet {
    @GuardedBy("this") private BigInteger lastNumber;
    @GuardedBy("this") private BigInteger[] lastFactors;
    @GuardedBy("this") private long hits;
    @GuardedBy("this") private long cacheHits;
    public synchronized long getHits() { return hits; }
    public synchronized double getCacheHitRatio() {
        return (double) cacheHits / (double) hits;
    }
    public void service(ServletRequest req, ServletResponse resp) {
        BigInteger i = extractFromRequest(req);
        BigInteger[] factors = null;
        synchronized (this) {
            ++hits;
            if (i.equals(lastNumber)) {
                ++cacheHits;
                factors = lastFactors.clone();
            }
        }
        if (factors == null) {
            factors = factor(i);
            synchronized (this) {
                lastNumber = i;
                lastFactors = factors.clone();
            }
        }
        encodeIntoResponse(resp, factors);
    }
}
```

# 3. Совместное использование объектов

Синхронизация также имеет еще один важный аспект: видимость памяти (memory visibility). Мы 
обеспечим потокам во время изменения объекта возможность видеть внесенные другим потоком 
изменения и опубликуем объекты с помощью синхронизации (явной или встроенной в библиотечные 
классы)

## 3.1. Видимость

Совместное использование переменных без синхронизации. Так делать не следует

```java
public class NoVisibility {
    private static boolean ready;
    private static int number;
    private static class ReaderThread extends Thread {
        public void run() {
            while (!ready)
                Thread.yield();
            System.out.println(number);
        }
    }
    public static void main(String[] args) {
        new ReaderThread().start();
        number = 42;
        ready = true;
    }
}
```

Без синхронизации компилятор, процессор и рабочая среда могут запутать порядок выполнения 
операций. Не стоит ожидать естественного порядка действий памяти в недостаточно 
синхронизированных многопоточных программах.

Нужно применять правильную синхронизацию, когда данные используются потоками совместно.

### 3.1.1 Устаревшие данные

Класс NoVisibility (3.1.) продемонстрировал один из путей появления устаревших данных (stale 
data), которые видит читающий поток, если синхронизация не используется всякий раз при обращении 
к переменной.

Устаревшие значения могут вызывать сбои в безопасности или жизнеспособности: неожиданные 
исключения, поврежденные структуры данных,неточные вычисления и бесконечные циклы.

Непотокобезопасный мутируемый держатель целого числа

```java
@NotThreadSafe
public class MutableInteger {
    private int value;
    public int get() { return value; }
    public void set(int value) { this.value = value; }
}
```

Потокобезопасный мутируемый держатель целого числа

```java
@ThreadSafe
public class SynchronizedInteger {
    @GuardedBy("this") private int value;
    public synchronized int get() { return value; }
    public synchronized void set(int value) { this.value = value; }
}
```

### 3.1.2. Неатомарные 64-разрядные операции

Если несколько одновременно записывают и считывают 64-разрядные переменные (long, double), то 
возможна ситуация когда можно получить верхние 32 бита одного значения и нижние 32 бита другого

### 3.1.3. Блокировка и видимость

Чтобы обеспечить видимость актуальных значений совместных волатильных переменных, 
синхронизируйте читающие и пишущие потоки на общем замке.

### 3.1.4. Волатильные переменные

Переменная volatile для компилятора и рабочей среды является совместной, то есть операции над 
ней не будут переупорядочены с другими операциями в памяти. Волатильные переменные не кэшируются 
в регистрах или кэшах, где данные скрыты от других процессоров, поэтому их чтение всегда 
возвращает самый последний результат операций записи.

На большинстве современных процессорных архитектур волатильные чтения ненамного дороже 
неволатильных

Используйте волатильные переменные только тогда, когда они упрощают реализацию и проверку 
политики синхронизации. И избегайте их использования, когда диагностика правильности требует 
утонченных рассуждений о видимости. Волатильные переменные должны обеспечивать видимость их 
собственного состояния, состояния объекта, на который они ссылаются, или важного события 
жизненного цикла (например, инициализации или выключения).

 Типичное использование волатильных переменных:

```java
volatile boolean asleep;
...
    while (!asleep)
        countSomeSheep();
```

Совет по отладке: в серверном приложении всегда указывайте переключатель командной строки JVM-
server во время вызова JVM даже для разработки и тестирования. Серверная JVM выполняет больше 
оптимизационных задач, чем клиентская JVM, например извлекает из цикла переменные, которые в нем 
не модифицируются. Код, который может показаться работающим в рабочей среде (клиентская JVM), 
может нарушиться в среде развертывания (серверная JVM). Если бы в листинге 3.4 мы забыли 
объявить переменную asleep как волатильную, то серверная JVM могла бы вынуть проверку из цикла 
(превратив его в бесконечный цикл), а клиентская JVM — не могла бы. Бесконечный цикл, который 
проявляется при разработке, стоит намного дешевле, чем тот, который обнаруживает себя в процессе 
эксплуатации кода.

Волатильные переменные удобны и часто используются в качестве флажка завершения, прерывания или 
статуса. Однако механизм volatile недостаточно силен, для того чтобы сделать операцию приращения 
(count++) атомарной в многопоточной среде. Поэтому:

Блокировка может гарантировать как видимость, так и атомарность, а волатильные переменные 
гарантируют только видимость.

Использование волатильных переменных оправданно при следующих
условиях:
- записи в переменную не зависят от ее текущего значения, либо есть гарантия, что значения
  переменной обновляются только одним потоком;
- переменная не участвует в инвариантах с другими переменными состояния;
- при обращении к переменной заранее не требуется блокировка.

## 3.2. Публикация и ускользание

Позволяем ускользнуть внутреннему мутируемому состоянию.
Так делать не следует

```java
class UnsafeStates {
    private String[] states = new String[] {
        "AK", "AL" ...
    };
    public String[] getStates() { return states; }
}
```

Любой вызывающий массив states элемент кода может изменить его содержимое. В данном случае 
предположительно приватный объект стал публичным.

Когда класс ThisEscape публикует слушателя EventListener, он неявно публикует и окаймляющий его 
экземпляр ThisEscape, потому что экземпляры внутреннего класса содержат скрытую ссылку на него.

Неявное разрешение ссылке this ускользнуть. 
Так делать не следует

```java
public class ThisEscape {
    public ThisEscape(EventSource source) {
        source.registerListener(
        new EventListener() {
            public void onEvent(Event e) {
                doSomething(e);
            }
         });
     }
}
```

### 3.2.1. Приемы безопасного конструирования

Не позволяйте ссылке this ускользнуть во время конструирования.

Объект находится в предсказуемом и непротиворечивом состоянии только при полноценности его 
конструктора. В противном случае возникает риск публикации неполно сконструированного объекта, 
даже если публикация является последней инструкцией в конструкторе. Объект с ускользнувшей 
ссылкой this считается ненадлежаще сконструированным

Не позволяйте ссылке this ускользнуть во время конструирования.

Ссылка this не должна ускользать из потока до тех пор, пока конструктор не возвратится. Ссылка 
this может храниться где-то конструктором, при условии что она не используется другим потоком до 
завершения конструирования.

Использование фабричного метода для предотвращения ускользания ссылки this во время 
конструирования

```java
public class SafeListener {
    private final EventListener listener;
    private SafeListener() {
        listener = new EventListener() {
            public void onEvent(Event e) {
                doSomething(e);
            }
        };
    }
    public static SafeListener newInstance(EventSource source) {
        SafeListener safe = new SafeListener();
        source.registerListener(safe.listener);
        return safe;
    }
}
```

## 3.3. Ограничение одним потоком

Сам язык не содержит механизмов ограничения объекта одним потоком. Такое ограничение станет 
элементом проекта вашей программы. Языковые и ядерные библиотеки предоставляют механизмы 
поддержки ограничения — локальные переменные и класс ThreadLocal, — но ответственность за их 
реализацию лежит на разработчике.

### 3.3.1. Узкоспециальное ограничение одним потоком

Более прочными формами ограничения одним потоком являются ограничение стеком и ThreadLocal.

### 3.3.2. Ограничение стеком

При ограничении стеком (stack confinement) объект может быть достигнут только через локальные 
переменные.

### 3.3.3. ThreadLocal

Класс ThreadLocal позволяет ассоциировать каждое значение в потоке с объектом, владеющим этим 
значением. Он предоставляет методы доступа get и set, поддерживающие отдельную копию значения 
для каждого потока, который его использует, поэтому get возвращает самое последнее значение, 
переданное в set из выполняющегося в настоящее время потока.

Используя класс ThreadLocal для хранения соединения JDBC, как в ConnectionHolder, вы обеспечите 
каждому потоку свое собственное соединение.


Использование класса ThreadLocal для ограничения одним потоком:

```java
private static ThreadLocal<Connection> connectionHolder = new ThreadLocal<Connection>() {
    public Connection initialValue() {
        return DriverManager.getConnection(DB_URL);
    }
};
public static Connection getConnection() {
    return connectionHolder.get();
}
```
Значения TreadLocal хранятся в самом объекте Thread, и когда поток терминируется, они могут быть
собраны сборщиком мусора.

## 3.4. Немутируемость

Немутируемые объекты всегда являются потокобезопасными.

### 3.4.1. Финальные поля

Объявляйте поля приватными, если они не нуждаются в большей видимости, и финальными — если они не
должны быть мутируемыми.

### 3.4.2 Пример: использование volatile для публикации немутируемых объектов

Немутируемый держатель для кэширования числа и его множителей

```java 
@Immutable
class OneValueCache {
    private final BigInteger lastNumber;
    private final BigInteger[] lastFactors;
    public OneValueCache(BigInteger i, BigInteger[] factors) {
        lastNumber = i;
        lastFactors = Arrays.copyOf(factors, factors.length);
    }
    public BigInteger[] getFactors(BigInteger i) {
        if (lastNumber == null || !lastNumber.equals(i))
            return null;
        else
            return Arrays.copyOf(lastFactors, lastFactors.length);
    }
}
```

Состояния гонки при доступе или обновлении родственных переменных могут быть устранены в 
немутируемом держателе даже без блокировки: когда поток приобретет на него ссылку, другой поток 
уже не сможет изменить его состояние. Чтобы обновить переменные, потребуется создать новый 
держатель, но потоки, работающие с предыдущим держателем, продолжат видеть его в непротиворечивом 
состоянии.

Кэширование последнего результата с помощью изменчивой ссылки на немутируемый держатель объекта

```java
@ThreadSafe
public class VolatileCachedFactorizer implements Servlet {
    private volatile OneValueCache cache = new OneValueCache(null, null);
    public void service(ServletRequest req, ServletResponse resp) {
        BigInteger i = extractFromRequest(req);
        BigInteger[] factors = cache.getFactors(i);
        if (factors == null) {
            factors = factor(i);
            cache = new OneValueCache(i, factors);
        }
        encodeIntoResponse(resp, factors);
    }
}
```

## 3.5. Безопасная публикация

Публикация объекта без надлежащей синхронизации. Так делать не следует

```java
// Небезопасная публикация
public Holder holder;
public void initialize() {
    holder = new Holder(42);
}
```

Вы будете удивлены, но из‑за проблем видимости держатель Holder может показаться другому потоку в 
противоречивом состоянии, даже если его инварианты были правильно установлены его конструктором! 
Именно ненадлежащая публикация заставит другой поток наблюдать частично сконструированный объект.

### 3.5.1. Ненадлежащая публикация: хорошие объекты становятся плохими

Не стоит надеяться на целостность частично сконструированных объектов. Наблюдающий поток может 
увидеть сначала объект в противоречивом состоянии, а затем внезапное изменение состояния. Если 
держатель Holder будет опубликован так, как в 3.5., при вызове метода assertSanity 
возникнет ошибка AssertionError!

Риск возникновения сбоя при ненадлежащей публикации

```java
public class Holder {
    private int n;
    public Holder(int n) { this.n = n; }
    public void assertSanity() {
        if (n != n)
            throw new AssertionError("Эта инструкция является ложной.");
    }
}
```

Проблема здесь не в самом классе Holder, а в его публикации. Holder может быть сделан 
невосприимчивым к ненадлежащей публикации, если объявить поле n финальным, что сделает класс 
Holder немутируемым

Поскольку синхронизация не использовалась для того, чтобы сделать класс Holder видимым для других 
потоков, другие потоки увидят либо устаревшее значение в поле holder (пустую ссылку null или 
другое), либо актуальное значение ссылки на holder, но устаревшие значения состояния Holder, либо 
устаревшее значение при первом чтении поля, а в следующий раз — более актуальное значение. 

Да, без достаточной синхронизации могут происходить очень странные вещи, если данные используются 
потоками совместно.

### 3.5.2. Немутируемые объекты и безопасность при инициализации

Немутируемые объекты могут безопасно использоваться потоками без дополнительной синхронизации, 
даже когда синхронизация для их публикации не используется.

### 3.5.3. Приемы безопасной публикации

Безопасную публикацию объекта, при которой ссылка на него и его состояние видна всем потокам в 
одно и то же время, можно провести с помощью:
- инициализации объектной ссылки из статического инициализатора;
- сохранения ссылки на него в волатильном поле либо в AtomicReference;
- сохранения ссылки на него в финальном поле надлежаще сконструированного объекта;
- сохранения ссылки на него в поле, которое надлежаще защищается замком.

Потокобезопасные библиотечные коллекции предлагают следующие гарантии безопасной публикации:
- ключ или значение, размещенные в Hashtable, synchronizedMap либо
  ConcurrentMap, безопасно публикуются в любом потоке, который извлекает их из ассоциативного
  массива Map (напрямую или через итератор);
- элемент, размещенный в Vector, CopyOnWriteArrayList, CopyOnWriteArraySet, synchronizedList либо
  synchronizedSet, безопасно публикуется в любом потоке, который извлекает его из коллекции;
- элемент, размещенный в BlockingQueue либо ConcurrentLinkedQueue, безопасно публикуется в любом
  потоке, который извлекает его из очереди.

### 3.5.4. Фактически немутируемые объекты

Объекты, которые не являются немутируемыми, но состояние которых не будет изменено после 
публикации, называются фактически немутируемыми (effectively immutable).

Безопасно опубликованные фактически немутируемые объекты могут безопасно использоваться любым 
потоком без дополнительной синхронизации.

### 3.5.5. Мутируемые объекты

Требования к публикации объекта зависят от его мутируемости:
- немутируемые объекты могут быть опубликованы любым механизмом;
- фактически немутируемые объекты должны быть безопасно опубликованы;
- мутируемые объекты должны быть безопасно опубликованы и быть либо потокобезопасными, либо
  защищенными замком.

### 3.5.6. Безопасное совместное использование объектов

Ниже приведены наиболее полезные политики для применения и совместного использования объектов в 
конкурентной программе: 
**Ограничение одним потоком.** Объект, ограниченный одним потоком, принадлежит эксклюзивно 
владеющему потоку, который может его изменять.

**Совместный доступ только для чтения.** Потоки могут обращаться к объекту, предназначенному 
только для чтения, конкурентно, без дополнительной синхронизации и возможности его изменять. 
Совместные объекты только для чтения включают немутируемые и фактически немутируемые объекты.

**Совместная потокобезопасность.** Потокобезопасный объект выполняет синхронизацию внутренне, 
поэтому потоки могут свободно обращаться к нему через его публичный интерфейс без дополнительной 
синхронизации.

**Защищенность.** С удержанием конкретного замка можно обращаться к объекту, инкапсулированному в 
другие потокобезопасные объекты, а также к опубликованному объекту, защищенному замком.

# 4. Компоновка объектов

В этой главе мы рассмотрим паттерны для безопасного структурирования классов.

## 4.1. Проектирование потокобезопасного класса

Проектирование потокобезопасного класса включает три этапа:
- идентификация переменных, формирующих состояние объекта;
- идентификация инвариантов, ограничивающих переменные состояния;
- создание политики для управления конкурентным доступом к состоянию объекта.

Простой потокобезопасный счетчик с использованием Java паттерна — монитор

```java
@ThreadSafe
public final class Counter {
    @GuardedBy("this") private long value = 0;
    public synchronized long getValue() {
        return value;
    }
    public synchronized long increment() {
        if (value == Long.MAX_VALUE)
            throw new IllegalStateException("переполнение счетчика");
        return ++value;
     }
}
```

### 4.1.1. Сбор требований к синхронизации

Многие классы имеют инварианты, идентифицирующие состояния как допустимые (valid) или 
недопустимые (invalid). Поле value в Counter имеет тип long. Состояние пространства типа long 
находится в диапазоне от Long.MIN_VALUE до Long.MAX_VALUE, но Counter ограничивает value только 
положительными значениями. 

Постусловия в операциях могут идентифицировать переход из состояния в состояние (state 
transitions) как недопустимый. Если текущее состояние объекта Counter равно 17, то единственным 
допустимым следующим состоянием должно быть 18.

Обеспечивайте потокобезопасность, учитывая роль инвариантов и постусловий. 

### 4.1.2. Операции, зависимые от состояния

Некоторые объекты имеют методы с предусловиями, основанными на состоянии. Предусловия, например, 
запрещают удалять элемент из пустой очереди, требуя для удаления состояние очереди «не пусто». 
Операции с предусловиями, основанными на состоянии, именуются зависимыми от состояния (state-
dependent)

Если в однопоточной программе предусловие не соблюдается, то операция завершается 
безрезультатно. Конкурентные же программы ожидают появление потока, для которого предусловие 
станет истинным, и затем продолжают выполнение операции. (wait и notify)

### 4.1.3. Владение состоянием

При определении переменных, формирующих состояние объекта, мы учитываем только те данные, которыми 
объект владеет. Владение не воплощено в языке явным образом, а является элементом проектирования 
класса.

Во многих случаях владение связано с инкапсуляцией — объект инкапсулирует состояние, которым владеет, 
и владеет состоянием, которое инкапсулирует. Именно владелец переменной состояния принимает решение о 
замковом протоколе, используемом для поддержания целостности ее состояния. Из факта владения вытекает 
обязанность контроля, которая после публикации ссылки на мутируемый объект приобретет совместный 
характер. Класс не владеет объектами, поставляемыми в его методы или конструкторы, если сам метод не 
предназначен для явной передачи права владения.

## 4.2. Ограничение одним экземпляром

Инкапсуляция данных в объекте ограничивает доступ к ним только методами объекта, что упрощает 
обеспечение постоянного доступа с удержанием замка.

Использование ограничения одним экземпляром

```java
@ThreadSafe
public class PersonSet {
    @GuardedBy("this")
    private final Set<Person> mySet = new HashSet<Person>();
    public synchronized void addPerson(Person p) {
        mySet.add(p);
    }
    public synchronized boolean containsPerson(Person p) {
        return mySet.contains(p);
    }
}
```

Ограничение одним экземпляром (synchronized) упрощает создание потокобезопасных классов, позволяя 
анализировать их потокобезопасность без проверки всей программы.

### 4.2.1. Мониторный шаблон Java

По принципу ограничения одним экземпляром работает и мониторный шаблон Java (Java monitor pattern)1: 
объект, подчиняющийся шаблону, инкапсулирует мутируемое состояние под защитой внутреннего замка.

Защита состояния с помощью приватного замка

```java
public class PrivateLock {
    private final Object myLock = new Object();
    @GuardedBy("myLock") Widget widget;
    void someMethod() {
        synchronized(myLock) {
            // Обратиться и изменить состояние виджета
        }
    }
}
```

Преимущество использования приватного замка — в его инкапсуляции, которая не позволяет клиентскому 
коду приобрести его и участвовать в политике его синхронизации, избавляя от необходимости проверки 
всей программы.

### 4.2.2. Пример: трекинг такси

Наш трекер такси будет программой для диспетчера таксопарка. Сначала мы построим его с помощью 
мониторного шаблона, а затем ослабим требования к инкапсуляции, сохраняя потокобезопасность.

Каждое такси будет идентифицироваться объектом String и иметь местоположение в координатах (x, y). 
Классы VehicleTracker инкапсулируют идентичность и местоположения известных такси

Просмотровый поток будет доставлять имена и местоположения такси и выводить их на дисплей:

```java
Map<String, Point> locations = vehicles.getLocations();
for (String key : locations.keySet())
    renderVehicle(key, locations.get(key));
```

Так же изменение координат:

```java
void vehicleMoved(VehicleMovedEvent evt) {
    Point loc = evt.getNewLocation();
    vehicles.setLocation(evt.getVehicleId(), loc.x, loc.y);
}
```

Потоки будут обращаться к модели данных конкурентно, и она должна быть потокобезопасной.
(Сам пример будет описан в последующих главах)

### 4.3. Делегирование потокобезопасности

Мониторная реализация трекера такси

```java
@ThreadSafe
public class MonitorVehicleTracker {
    @GuardedBy("this")
    private final Map<String, MutablePoint> locations;
    public MonitorVehicleTracker( Map<String, MutablePoint> locations) {
        this.locations = deepCopy(locations);
    }
    public synchronized Map<String, MutablePoint> getLocations() {
        return deepCopy(locations);
    }
    public synchronized MutablePoint getLocation(String id) {
        MutablePoint loc = locations.get(id);
        return loc == null ? null : new MutablePoint(loc);
    }
    public synchronized void setLocation(String id, int x, int y) {
        MutablePoint loc = locations.get(id);
        if (loc == null) throw new IllegalArgumentException("No such ID: " + id);
        loc.x = x;
        loc.y = y;
    }
    private static Map<String, MutablePoint> deepCopy(Map<String, MutablePoint> m) {
        Map<String, MutablePoint> result = new HashMap<String, MutablePoint>();
        for (String id : m.keySet()) result.put(id, new MutablePoint(m.get(id)));
        return Collections.unmodifiableMap(result);
    }
}
// Изменяемый класс точки, подобный java.awt.Point
@NotThreadSafe
public class MutablePoint {
    public int x, y;
    public MutablePoint() { x = 0; y = 0; }
    public MutablePoint(MutablePoint p) {
        this.x = p.x;
        this.y = p.y;
    }
}
```

### 4.3.1. Пример: трекер такси с использованием делегирования

Давайте сконструируем версию трекера такси, которая делегирует свои обязанности по потокобезопасности 
неизменяемому классу. Местоположения хранятся в ассоциативном массиве Map, поэтому мы начнем с 
потокобезопасной реализации хеш-массива ConcurrentHashMap.

Неизменяемый класс точки Point, используемый трекером DelegatingVehicleTracker

```java
@Immutable
public class Point {
    public final int x, y;
    public Point(int x, int y) {
        this.x = x;
        this.y = y;
    }
}
```

Класс Point является потокобезопасным, поэтому нам больше не нужно копировать местоположения при их 
возврате.

Делегирование потокобезопасности в хеш-массив ConcurrentHashMap

```java
@ThreadSafe
public class DelegatingVehicleTracker {
    private final ConcurrentMap<String, Point> locations;
    private final Map<String, Point> unmodifiableMap;
    public DelegatingVehicleTracker(Map<String, Point> points) {
        locations = new ConcurrentHashMap<String, Point>(points);
        unmodifiableMap = Collections.unmodifiableMap(locations);
    }
    public Map<String, Point> getLocations() {
        return unmodifiableMap;
    }
    public Point getLocation(String id) {
        return locations.get(id);
    }
    public void setLocation(String id, int x, int y) {
        if (locations.replace(id, new Point(x, y)) == null)
            throw new IllegalArgumentException("недопустимое имя такси: " + id);
    }
}
```

Обратите внимание, что мы немного изменили поведение класса трекера такси: мониторная версия 
возвращала снимок местоположений, а делегирующая версия возвращает их неизменяемое, но «живое» 
представление. Это означает, что если поток A вызывает метод getLocations, а поток B позже изменяет 
местоположение некоторых точек, эти изменения отражаются в хеш-массиве, возвращенном потоку A. Как мы 
отмечали ранее, это может быть преимуществом (более актуальные данные) либо недостатком (потенциально 
противоречивое представление таксопарка), в зависимости от ваших требований.

Если требуется неизменное представление парка, то метод getLocations может вернуть неглубокую копию 
хеш-массива местоположений.

### 4.3.2. Независимые переменные состояния

Делегировать потокобезопасность более чем одной базовой переменной состояния возможно, если эти 
переменные независимы, то есть композитный класс не накладывает инварианты с их участием.

Делегирование потокобезопасности нескольким базовым переменным состояния

```java
public class VisualComponent {
    private final List<KeyListener> keyListeners = new CopyOnWriteArrayList<KeyListener>();
    private final List<MouseListener> mouseListeners = new CopyOnWriteArrayList<MouseListener>();
    public void addKeyListener(KeyListener listener) {
        keyListeners.add(listener);
    }
    public void addMouseListener(MouseListener listener) {
        mouseListeners.add(listener);
    }
    public void removeKeyListener(KeyListener listener) {
        keyListeners.remove(listener);
    }
    public void removeMouseListener(MouseListener listener) {
        mouseListeners.remove(listener);
    }
}
```

Каждый список является потокобезопасным, и поскольку нет ограничений между их состояниями, 
VisualComponent может делегировать свои обязанности по потокобезопасности базовым объектам 
mouseListeners и keyListeners.

### 4.3.3. Случаи безуспешного делегирования

Класс диапазона чисел, недостаточно защищающий свои инварианты. Так делать не следует

```java
public class NumberRange {
    // ИНВАРИАНТ: lower <= upper
    private final AtomicInteger lower = new AtomicInteger(0);
    private final AtomicInteger upper = new AtomicInteger(0);
    public void setLower(int i) {
        // Предупреждение – небезопасная операция "проверить и затем действовать"
        if (i > upper.get()) 
            throw new IllegalArgumentException("не могу установить lower равным " + i + " > upper");
        lower.set(i);
    }
    public void setUpper(int i) {
        // Предупреждение – небезопасная операция "проверить и затем действовать"
        if (i < lower.get()) 
            throw new IllegalArgumentException("не могу установить upper равным " + i + " < lower");
        upper.set(i);
    }
    public boolean isInRange(int i) {
        return (i >= lower.get() && i <= upper.get());
    }
}
```
Класс NumberRange не является потокобезопасным: он не соблюдает инвариант, который ограничивает lower 
и upper. Методы setLower и setUpper пытаются соблюсти этот инвариант, но безуспешно, так как являются 
последовательностями операций «проверить и затем действовать», но их блокировка не обеспечивает им 
атомарности. Если в диапазоне (0, 10) один поток вызовет setLower(5), а другой в то же время — 
setUpper(4), то при неудачной временнˆой координации оба потока пройдут проверку в методах доступа 
set, и выполнятся два изменения, создав диапазон (5, 4) — недопустимое состояние.

Потокобезопасность класса NumberRange может обеспечить блокировка, которая сохранит его инварианты и 
защитит lower и upper замком, чтобы препятствовать их публикации.

### 4.3.4. Публикация базовых переменных состояния

Если переменная состояния является потокобезопасной, не участвует в инвариантах, ограничивающих ее 
значение, и не имеет запрещенных переходов из состояния в состояние для любой из ее операций, то она 
может быть безопасно опубликована.

### 4.3.5. Пример: трекер такси, публикующий свое состояние

Рассмотрим версию трекера такси с публикацией базового мутируемого состояния путем размещения на 
мутируемых, но потокобезопасных точках.

Класс потокобезопасной мутируемой точки

```java
@ThreadSafe
public class SafePoint {
    @GuardedBy("this") private int x, y;
    private SafePoint(int[] a) { this(a[0], a[1]); }
    public SafePoint(SafePoint p) { this(p.get()); }
    public SafePoint(int x, int y) {
        this.x = x;
        this.y = y;
    }
    public synchronized int[] get() {
        return new int[] { x, y };
    }
    public synchronized void set(int x, int y) {
        this.x = x;
        this.y = y;
    }
}
```

Приватный конструктор существует для того, чтобы избежать состояния гонки, возникающего при 
реализации конструктора копирования, такого как this(p.x, p.y); это пример захвата частного 
конструктора а (private constructorcapture)

Класс SafePoint в листинге 4.11 предоставляет метод доступа get, который извлекает значения x и y 
одновременно, возвращая двухэлементный массив1 . Наличие двух отдельных методов get для x и y 
заставило бы вызывающий элемент кода видеть противоречивое значение.

Трекер такси, безопасно публикующий базовое состояние

```java
@ThreadSafe
public class PublishingVehicleTracker {
    private final Map<String, SafePoint> locations;
    private final Map<String, SafePoint> unmodifiableMap;
    public PublishingVehicleTracker(Map<String, SafePoint> locations) {
        this.locations = new ConcurrentHashMap<String, SafePoint>(locations);
        this.unmodifiableMap = Collections.unmodifiableMap(this.locations);
    }
    public Map<String, SafePoint> getLocations() {
        return unmodifiableMap;
    }
    public SafePoint getLocation(String id) {
        return locations.get(id);
    }
    public void setLocation(String id, int x, int y) {
        if (!locations.containsKey(id))
            throw new IllegalArgumentException("недопустимое имя транспортного средства: " + id);
         locations.get(id).set(x, y);
    }
}
```

Вызывающие элементы кода не могут добавлять или удалять такси, но могут изменять местоположение 
одного из них путем мутирования значений SafePoint в возвращенном ассоциативном массиве Map. «Живой» 
характер ассоциативного массива Map может быть преимуществом либо недостатком, в зависимости от 
требований.

## 4.4. Добавление функциональности в существующие потокобезопасные классы

Чтобы создать потокобезопасный список с атомарной операцией «добавить, если отсутствует», нам 
потребуется синхронизированный список List, который предоставляет методы contains и add.

Самый безопасный способ добавить атомарную операцию — это изменить класс таким образом, чтобы он 
начал ее поддерживать. Мы не всегда имеем доступ к исходному коду, однако, если мы его получили, нам 
нужно понимать принятую в коде политику синхронизации, которая контролируется в одном исходном файле. 
Можно расширить класс (предназначенный для расширения). Класс BetterVector расширяет класс Vector, 
добавляя метод putIfAbsent.

Расширение класса Vector для использования метода «добавить, если отсутствует»

```java
@ThreadSafe
public class BetterVector<E> extends Vector<E> {
    public synchronized boolean putIfAbsent(E x) {
        boolean absent = !contains(x);
        if (absent) add(x);
        return absent;
     }
}
```

### 4.4.1. Блокировка на стороне клиента

Непотокобезопасная попытка реализовать метод «добавить, если отсутствует». Так делать не следует

```java
@NotThreadSafe
public class ListHelper<E> {
    public List<E> list = Collections.synchronizedList(new ArrayList<E>());
    ...
    public synchronized boolean putIfAbsent(E x) {
        boolean absent = !list.contains(x);
        if (absent) list.add(x);
        return absent;
    }
}
```

Метод putIfAbsent синхронизирован? Да, но на неправильном замке. Класс ListHelper обеспечивает только 
иллюзию синхронизации: на самом деле операции используют разные замки, и метод putIfAbsent не 
воспринимается другими операциями как атомарный.

Исправить этот пример поможет блокировка на стороне клиента (clientside locking) или внешняя 
блокировка.

Реализация метода «добавить, если отсутствует» с блокировкой на стороне клиента

```java
@ThreadSafe
public class ListHelper<E> {
    public List<E> list = Collections.synchronizedList(new ArrayList<E>());
    ...
    public boolean putIfAbsent(E x) {
        synchronized (list) {
            boolean absent = !list.contains(x);
            if (absent) list.add(x);
            return absent;
        }
    }
}
```

В то время как расширение класса нарушает инкапсуляцию реализации, блокировка на стороне клиента 
нарушает инкапсуляцию политики синхронизации.

### 4.4.2. Компоновка

Добавить атомарную операцию в существующий класс поможет компоновка (composition).

Реализация метода «добавить, если отсутствует» с использованием компоновки

```java
@ThreadSafe
public class ImprovedList<T> implements List<T> {
    private final List<T> list;
    public ImprovedList(List<T> list) { this.list = list; }
    public synchronized boolean putIfAbsent(T x) {
        boolean contains = list.contains(x);
        if (contains) list.add(x);
        return !contains;
    }
    public synchronized void clear() { list.clear(); }
    // ... делегировать остальные списковые методы схожим образом
}
```

Класс ImprovedList добавляет новый уровень блокировки с помощью своего внутреннего замка, не обращая 
внимания на наличие или отсутствие потокобезопасности у List. Дополнительная синхронизация может 
наложить штраф на производительность, но такое использование мониторного шаблона Java для 
инкапсуляции существующего списка гарантированно обеспечит потокобезопасность, при условии что класс 
содержит единственную ожидающую обработки ссылку на базовый список.

## 4.5. Документирование политик синхронизации

Документируйте гарантии потокобезопасности класса для клиентов и политику синхронизации — для 
сопроводителей. 

### 4.5.1. Толкование расплывчатой документации

Спецификации технологии Java мало сообщают о гарантиях потокобезопасности и требованиях к 
интерфейсам, таким как ServletContext, HttpSession и DataSource. Поскольку эти интерфейсы реализуются 
поставщиком контейнера или базы данных, часто невозможно просмотреть их код. И что же нам делать?

Догадываться. Интерпретировать спецификацию с точки зрения того, кто будет ее реализовывать.

# 5 Строительные блоки

В предыдущей главе мы описали несколько технических решений для конструирования потокобезопасных 
классов. Эта глава посвящена использованию конкурентных строительных блоков, таких как коллекции и 
синхронизаторы.

## 5.1. Синхронизированные коллекции 

К синхронизированным классам коллекций (synchronized collection classes) относятся Vector и 
Hashtable, часть исходного JDK, а также добавленные в JDK 1.2 синхронизированные оберточные классы, 
создаваемые фабричными методами Collections.synchronizedXxx. Эти классы обеспечивают 
потокобезопасность, инкапсулируя свое состояние и синхронизуя каждый публичный метод таким образом, 
чтобы только один поток за один раз мог обратиться к состоянию коллекции.

### 5.1.1. Проблемы синхронизированных коллекций

Синхронизированные коллекции являются потокобезопасными, но, когда потоки имеют возможность 
конкурентно изменять коллекцию, требуется блокировка на стороне клиента для защиты составных 
действий. Такие действия включают итеративный обход (доставку элементов из коллекции), навигацию 
(отыскание следующего элемента) и условные операции (связывание ключа K с неким значением).

Составные действия над объектом Vector, приводящие к запутанным результатам

```java
public static Object getLast(Vector list) {
    int lastIndex = list.size() - 1;
    return list.get(lastIndex);
}
public static void deleteLast(Vector list) {
    int lastIndex = list.size() - 1;
    list.remove(lastIndex);
}
```

Сами методы не могут повредить Vector — опасен элемент кода, вызывающий их. Если поток A вызывает 
метод getLast, а поток B — метод deleteLast, то эти операции перемежаются и метод getLast выдает 
исключение ArrayIndexOutOfBoundsException. Между вызовом метода size и последующим вызовом метода 
getlast объект Vector сжимается и индекс, вычисленный на первом шаге, перестает быть допустимым.

Составные действия над объектом Vector с использованием блокировки на стороне клиента

```java
public static Object getLast(Vector list) {
    synchronized (list) {
        int lastIndex = list.size() - 1;
        return list.get(lastIndex);
    }
}
public static void deleteLast(Vector list) {
    synchronized (list) {
        int lastIndex = list.size() - 1;
        list.remove(lastIndex);
    }
}
```

Итеративный обход, который может выдавать исключение ArrayIndexOutOfBoundsException

```java
for (int i = 0; i < vector.size(); i++)
    doSomething(vector.get(i));
```

Блокировка на стороне клиента влияет на масштабируемость. В течение всего времени итеративного обхода 
владея замком на Vector, мы не позволяем другим потокам изменять его. К сожалению, от этого страдает 
конкурентность.

Итеративный обход с блокировкой на стороне клиента

```java
synchronized (vector) {
    for (int i = 0; i < vector.size(); i++)
        doSomething(vector.get(i));
}
```

### 5.1.2. Итераторы и исключение ConcurrentModificationException

Ниже показан итеративный обход коллекции с использованием синтаксиса цикла for-each. javac генерирует 
код, который использует итератор, многократно вызывая hasNext и next. Чтобы предотвратить исключение 
ConcurrentModificationException, надо владеть коллекционным замком в течение **всего** времени 
итеративного обхода.

Итеративный обход списка с помощью итератора

```java
List<Widget> widgetList= Collections.synchronizedList(new ArrayList<Widget>());
...
// Может выдать ConcurrentModificationException
for (Widget w : widgetList)
    doSomething(w);
```

Однако блокировка коллекции во время итеративного обхода не всегда уместна. При больших коллекциях и 
задачах ожидание завершения итерации становится слишком долгим.

Любое запирание коллекций на значительные периоды времени снижает масштабируемость приложения: чем 
дольше замок занят, тем больше вероятность того, что он будет оспариваться другими потоками

Альтернативой запиранию коллекции во время итеративного обхода является ее клонирование и итеративный 
обход клона. Клон ограничен одним потоком, но коллекция все равно должна быть защищена замком во 
время клонирования. Насколько клонирование оправданно, зависит от размера коллекции, объема работы, 
выполняемой для каждого элемента, относительной частоты итераций, а также требований к отзывчивости и 
пропускной способности. 

### 5.1.3. Скрытые итераторы

Использовать блокировку везде, где может выполняться итеративный обход совместной коллекции, не так 
просто. Итераторы бывают скрытыми, как в HiddenIterator в листинге 5.6, где явного итеративного 
обхода нет, но код, выделенный жирным шрифтом, его подразумевает. Конкатенация строк преобразуется 
компилятором в вызов StringBuilder.append(Object), который, в свою очередь, активирует метод 
toString, который в стандартных коллекциях выполняет итеративный обход.

Итеративный обход, скрытый внутри конкатенации строк. Так делать не следует

```java
public class HiddenIterator {
    @GuardedBy("this") private final Set<Integer> set = new HashSet<Integer>();
    public synchronized void add(Integer i) { set.add(i); }
    public synchronized void remove(Integer i) { set.remove(i); }
    public void addTenThings() {
        Random r = new Random();
        for (int i = 0; i < 10; i++)
            add(r.nextInt());
        System.out.println("ОТЛАДКА: добавлено десять элементов в " + set);
    }
}
```

Итеративный обход также косвенно активируется коллекционными методами hashCode и equals, которые 
могут вызываться, если коллекция используется в качестве элемента или ключа другой коллекции.

## 5.2. Конкурентные коллекции

Синхронизированные коллекции обеспечивают потокобезопасность, сериализуя весь доступ к своему 
состоянию. Стоимость этого подхода равна слабой конкурентности. Совершенствуя синхронизированные 
коллекции, Java предоставляет несколько конкурентных коллекционных классов.

Версия предлагает хеш-массив ConcurrentHashMap вместо синхронизированных хешированных реализаций 
ассоциативного массива Map, и CopyOnWriteArrayList вместо синхронизированных реализаций списка List 
для случаев, где обход является доминирующей операцией. Новый интерфейс ассоциативного массива 
ConcurrentMap поддерживает распространенные составные действия, такие как операция «добавить, если 
отсутствует», замена и условное удаление

Замена синхронизированных коллекций конкурентными коллекциями может предложить значительные улучшения 
масштабируемости при небольшом риске.

### 5.2.1. ConcurrentHashMap

Класс ConcurrentHashMap — это хешированный ассоциативный массив Map, аналогичный хеш-массиву HashMap, 
но использующий другую замковую стратегию. Вместо синхронизации каждого метода на общем замке и 
ограничения доступа одним потоком за раз он использует замковое расщепление на полосы (lock striping, 
см. раздел 11.4.3), расширяющее возможности совместного доступа к ассоциативному массиву. Оно 
обеспечивает конкурентность между читающими потоками, между читателями и писателями и между 
писателями. Результатом является высокая пропускная способность в рамках конкурентного доступа с 
небольшим штрафом на производительность для однопоточного доступа.

Также класс ConcurrentHashMap предоставляет итераторы, которые не выдают исключение 
ConcurrentModificationException, являются не быстро отказывающими, а слабо непротиворечивыми (weakly 
consistent). Они допускают конкурентное выполнение изменений, перебирают элементы в том порядке, в 
каком они существовали при конструировании итератора, и могут (не обязательно) отражать изменения в 
коллекцию.

### 5.2.2. Дополнительные атомарные операции над ассоциативным массивом

Поскольку хеш-массив ConcurrentHashMap не заперт для эксклюзивного доступа, мы не можем использовать 
блокировку на стороне клиента для создания новых атомарных операций как в разделе 4.4.1. Однако ряд 
составных операций («добавить, если отсутствует», «удалить, если равно» и «заменить, если равно») 
сразу задаются интерфейсом ConcurrentMap как атомарные.

Интерфейс ConcurrentMap

```java
public interface ConcurrentMap<K,V> extends Map<K,V> {
    // Вставить в ассоциативный массив, только если ни одно значение не соответствует ключу K
    V putIfAbsent(K key, V value);
    // Удалить, только если ключу K соответствует значение V
    boolean remove(K key, V value);
    // Заменить значение, только если ключу K соответствует старое значение oldValue
    boolean replace(K key, V oldValue, V newValue);
    // Заменить значение, только если ключу K соответствует некое значение
    V replace(K key, V newValue);
}
```

### 5.2.3. CopyOnWriteArrayList 

Класс CopyOnWriteArrayList является конкурентной версией синхронизированного спискового класса List, 
который предлагает более высокую конкурентность и устраняет необходимость в блокировке или 
клонировании коллекции во время итеративного обхода.

Очевидно, что копирование резервного массива сопряжено с определенной стоимостью, и его целесообразно 
использовать только тогда, когда итеративный обход встречается гораздо чаще, чем изменение. Например, 
доставка уведомления требует итеративного обхода списка зарегистрированных слушателей и вызова 
каждого из них, а регистрация или дерегистрация слушателей происходят гораздо реже.

Итераторы CopyOnWriteArrayList сохраняют ссылку на резервный массив, который был актуальным в начале 
итеративного обхода, и так как он никогда не изменяется, синхронизация им нужна ненадолго — чтобы 
обеспечить видимость содержимого массива. Потоки могут выполнять итеративный обход коллекции, не 
мешая потокам, желающим изменить ее. Итераторы не выдают исключения ConcurrentModificationException и 
возвращают элементы, не измененные с момента создания итератора.

### 5.3. Блокирующие очереди и паттерн «производитель-потребитель»

Блокирующие очереди поддерживают паттерн проектирования произ‑ водитель-потребитель (producer-
consumer), который помещает рабочие элементы в список предстоящих дел для последующей обработки, 
вместо того чтобы обрабатывать их сразу по мере их идентификации.

Ограниченные очереди делают вашу программу устойчивой к перегрузке

Встраивайте управление ресурсами в проект с помощью блокирующих очередей, причем гораздо проще делать 
это заранее, чем модернизировать код позже.

### 5.3.1. Пример: поиск на рабочем столе

Разложим на производителей и потребителей работу агента, который сканирует локальные диски на наличие 
документов и индексирует их для последующего поиска

Разложение обхода файлов и индексации на отдельные действия приводит к лучшей читаемости кода. 
Производитель и потребитель могут выполняться конкурентно: если один привязан к вводу-выводу, а 
другой — к процессору, то конкурентное их выполнение даст более высокую совокупную пропускную 
способность, чем последовательное.

Задачи производителя и потребителя в настольном поисковом приложении

```java
public class FileCrawler implements Runnable {
    private final BlockingQueue<File> fileQueue;
    private final FileFilter fileFilter;
    private final File root;
    public void run() {
        try {
            crawl(root);
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
    }
    private void crawl(File root) throws InterruptedException {
        File[] entries = root.listFiles(fileFilter);
        if (entries != null) {
            for (File entry : entries)
                if (entry.isDirectory())
                    crawl(entry);
                else if (!alreadyIndexed(entry))
                    fileQueue.put(entry);
        }
    }
}
public class Indexer implements Runnable {
    private final BlockingQueue<File> queue;
    public Indexer(BlockingQueue<File> queue) {
        this.queue = queue;
    }
    public void run() {
        try {
            while (true)
                indexFile(queue.take());
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
    }    
}
```

Запуск поиска на рабочем столе

```java
public static void startIndexing(File[] roots) {
    BlockingQueue<File> queue = new LinkedBlockingQueue<File>(BOUND);
    FileFilter filter = new FileFilter() {
        public boolean accept(File file) { return true; }
    };
    for (File root : roots) new Thread(new FileCrawler(queue, filter, root)).start();
    for (int i = 0; i < N_CONSUMERS; i++)
        new Thread(new Indexer(queue)).start();
}
```

### 5.3.2. Серийное ограничение одним потоком

Паттерны «производитель-потребитель» и блокирующие очереди поддерживают серийное ограничение одним 
потоком (serial thread confinement) мутируемых объектов. Эксклюзивное владение объектом может быть 
«перенесено» другому потоку путем безопасной публикации. Исходный владелец не будет касаться объекта 
снова, а новый владелец может свободно его изменять.

Для передачи права владения мутируемым объектом можно использовать и другие механизмы публикации, но 
необходимо обеспечивать передачу эстафеты только одному потоку. Лучше всего с этим справляются 
блокирующие очереди. Немного дополнительной работы в этом направлении по требуют атомарный метод 
remove ассоциативного массива ConcurrentMap или метод compareAndSet атомарной ссылки AtomicReference.

### 5.3.3. Двухсторонние очереди и кража работы

Java 6 также предоставляет очереди Deque и BlockingDeque, которые расширяют очереди Queue и 
BlockingQueue. Реализации класса Deque включают ArrayDeque и LinkedBlockingDeque.

Блокирующие очереди поддаются паттерну «производитель-потребитель», а двусторонние очереди — 
родственному паттерну под называнием кража работы (work stealing). Если потребитель исчерпывает 
работу в собственной очереди, он может украсть работу из чужой, что улучшает масштабируемость из-за 
сокращения конфликта: потребитель чаще обращается к собственной очереди, а просмотр чужой очереди 
начинает с хвоста. Таким образом каждый потребитель занят.

## 5.4. Блокирующие и прерываемые методы

Потоки могут блокировать продвижение, если ожидают завершения ввода-вывода, приобретения замка, 
пробуждения ото сна Thread.sleep или результата вычисления в другом потоке. Помещаясь в состояние 
BLOCKED, WAITING или TIMED_WAITING, поток не контролирует задачу, завершения которой ожидает, и 
возвращается в состояние работоспособности RUNNABLE только после возникновения внешнего события.

Методы put и take класса BlockingQueue выдают проверяемое исключение InterruptedException, как и ряд 
других библиотечных методов, таких как Thread.sleep. Данное исключение отличает блокирующие методы, 
которые активно сопротивляются собственному прерыванию.

Вызывая метод, который выдает исключение InterruptedException, ваш метод также становится блокирующим 
и должен уметь откликаться на прерывание. В случае библиотечного кода существует два варианта:

- Распространить исключение InterruptedException. Эта политика предусматривает неотлавливание
  исключения либо его отлавливание и повторную выдачу после выполнения краткой очистки.
- Восстановить прерывание. Когда распространить исключение невозможно (например, код является частью
  Runnable), необходимо перехватить исключение и восстановить статус прерванности, вызвав метод
  interrupt в текущем потоке, чтобы код выше в стеке вызовов видел выполненное прерывание.

Восстановление прерванного статуса

```java
public class TaskRunnable implements Runnable {
    BlockingQueue<Task> queue;
    ...
    public void run() {
        try {
            processTask(queue.take());
        } catch (InterruptedException e) {
            // восстановить статус прерванности
            Thread.currentThread().interrupt();
        }
    }
}
```

## 5.5. Синхронизаторы

Синхронизатор (synchronizer) — это любой объект, координирующий поток управления в остальных потоках, 
основываясь на их состоянии. В качестве синхронизаторов могут выступать блокирующие очереди, 
семафоры, барьеры и защелки. В платформенной библиотеке существует несколько классов синхронизаторов. 
Если они не отвечают вашим потребностям, то вы можете создать свои.

### 5.5.1. Защелки

Защелка (latch) представляет собой синхронизатор, который может задерживать продвижение потоков до 
достижения своего конечного состояния. Он действует как закрытый шлюз, который в определенный момент 
разрешает всем потокам пройти, и навсегда остается открытым. Защелки сдерживают некие действия до 
завершения других важных действий, приведенных ниже:
- Инициализация ресурсов.
- Запуск служб, от которых зависит действие.
- Готовность всех участников

Класс CountDownLatch представляет собой гибкую реализацию защелки. Состояние защелки состоит из 
счетчика, инициализируемого положительным числом ожидаемых событий. Метод countDown уменьшает 
счетчик, сигнализируя о том, что произошло событие, и методы await ожидают до тех пор, пока счетчик 
не достигнет нуля, т. е. все события завершатся.

Использование CountDownLatch для запуска и остановки потоков в тестах с хронометражем

```java
public class TestHarness {
    public long timeTasks(int nThreads, final Runnable task) throws InterruptedException {
        final CountDownLatch startGate = new CountDownLatch(1);
        final CountDownLatch endGate = new CountDownLatch(nThreads);
        for (int i = 0; i < nThreads; i++) {
            Thread t = new Thread() {
                public void run() {
                    try {
                        startGate.await();
                        try {
                            task.run();
                        } finally {
                            endGate.countDown();
                        }
                    } catch (InterruptedException ignored) { }
                }
            };
            t.start();
        }
        long start = System.nanoTime();
        startGate.countDown();
        endGate.await();
        long end = System.nanoTime();
        return end-start;
    }
}
```

### 5.5.2. FutureTask

FutureTask действует как защелка: он реализует Future, описывающий абстрактные вычисления, приносящие 
результат, которые реализуются с помощью интерфейса Callable, эквивалентного Runnable. Они могут 
находиться в состоянии ожидания выполнения, самого выполнения либо завершения (нормального 
завершения, отмены или прерывания). FutureTask, приняв завершенное состояние, остается в нем навсегда.

Использование FutureTask для предварительной загрузки данных, которые потребуются позже

public class Preloader {
    private final FutureTask<ProductInfo> future = new FutureTask<ProductInfo>(
                                                       new Callable<ProductInfo>() {
        public ProductInfo call() throws DataLoadException {
            return loadProductInfo();
        }
    });
    private final Thread thread = new Thread(future);
    public void start() { thread.start(); }
    public ProductInfo get() throws DataLoadException, InterruptedException {
        try {
            return future.get();
        } catch (ExecutionException e) {
            Throwable cause = e.getCause();
            if (cause instanceof DataLoadException) throw (DataLoadException) cause;
            else
                throw launderThrowable(cause);
        }
    }
}

### 5.5.3. Семафоры

Счетные семафоры (сounting semaphores) регулируют число действий, способных обращаться к 
определенному ресурсу или выполнять одну и ту же задачу в одно и то же время. Счетные семафоры можно 
использовать для реализации ресурсных пулов или наложения лимита на коллекцию.

Использование семафора для связывания коллекции

```java
public class BoundedHashSet<T> {
    private final Set<T> set;
    private final Semaphore sem;
    public BoundedHashSet(int bound) {
        this.set = Collections.synchronizedSet(new HashSet<T>());
        sem = new Semaphore(bound);
    }
    public boolean add(T o) throws InterruptedException {
        sem.acquire();
        boolean wasAdded = false;
        try {
            wasAdded = set.add(o);
            return wasAdded;
        }
        finally {
            if (!wasAdded) sem.release();
        }
    }
    public boolean remove(Object o) {
        boolean wasRemoved = set.remove(o);
        if (wasRemoved) sem.release();
        return wasRemoved;
    }
}
```

### 5.5.4. Барьеры

Барьеры (barriers) подобны защелкам в том, что они блокируют группу потоков до наступления какого-то 
события. Но в отличие от защелки барьер заставляет потоки вместе проходить барьерную точку в одно и 
то же время, чтобы продолжить работу. Защелки предназначены для ожидания событий, а барьеры — для 
ожидания других потоков.

Класс CyclicBarrier позволяет фиксированному числу сторон неоднократно назначать встречу в барьерной 
точке. Он полезен в параллельных итеративных алгоритмах, которые разбивают задачу на фиксированное 
число независимых подзадач. Потоки достигают барьерной точки и вызывают метод await, который 
блокирует продвижение, пока все потоки не сделают то же самое. Если барьер успешно пройден, все 
потоки выпускаются, и барьер переустанавливается для следующего использования. Если время на вызов 
метода await истекает либо блокированный им поток прерывается, барьер считается неисправным, и все 
вызовы метода await, ожидающие обработки, терминируются с исключением BrokenBarrierException. Если 
барьер успешно пройден, то метод await возвращает уникальный индекс прибытия каждому потоку. 
CyclicBarrier также позволяет передавать барьерное действие конструктору, реализуя интерфейс Runnable 
в одном из подзадачных потоков, после прохождения барьера, но до освобождения блокированных потоков.

Координирование вычислений в клеточном автомате с помощью барьера CyclicBarrier

```java
public class CellularAutomata {
    private final Board mainBoard;
    private final CyclicBarrier barrier;
    private final Worker[] workers;
    public CellularAutomata(Board board) {
        this.mainBoard = board;
        int count = Runtime.getRuntime().availableProcessors();
        this.barrier = new CyclicBarrier(count,
            new Runnable() {
                public void run() {
                    mainBoard.commitNewValues();
                }
            });
        this.workers = new Worker[count];
        for (int i = 0; i < count; i++) workers[i] = new Worker(mainBoard.getSubBoard(count, i));
    }
    private class Worker implements Runnable {
        private final Board board;
        public Worker(Board board) { this.board = board; }
        public void run() {
            while (!board.hasConverged()) {
                for (int x = 0; x < board.getMaxX(); x++)
                    for (int y = 0; y < board.getMaxY(); y++)
                        board.setNewValue(x, y, computeValue(x, y));
                try {
                    barrier.await();
                } catch (InterruptedException ex) {
                    return;
                } catch (BrokenBarrierException ex) {
                    return;
                }
            }
        }
    }
    public void start() {
        for (int i = 0; i < workers.length; i++)
            new Thread(workers[i]).start();
        mainBoard.waitForConvergence();
    }
}
```














