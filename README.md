#TODO: бонусом сделать анализ всей concurrency библиотеки 

# То, что узнал в книге "Java Concurrency in practice" 

## Описание

Это мой заметки того, что я узнал изкниги "Java Concurrency in practice"

Если Вы автор и считаете, что данный конспект нарушает авторские права - прошу сообщить, я сделаю этот репозиторий
приватным.

# 1. Введение

# 2. Потокобезопастность

Написание потокобезопасного кода — это, по сути, управление доступом к состоянию и, в частности, 
к совместному (shared) мутируемому состоянию (mutable state).

При проектировании потокобезопасных классов хорошие объектно‑ориентированные технические решения: 
инкапсуляция, немутируемость и четкая спецификация инвариантов — будут вашими помощниками.

## 2.1. Что такое потокобезопастность 

Класс является потокобезопасным, если он ведет себя правильно во время доступа из многочисленных 
потоков, независимо от того, как выполнение этих потоков планируется или перемежается рабочей 
средой, и без дополнительной синхронизации или другой координации со стороны вызывающего кода.

Потокобезопасные классы инкапсулируют любую необходимую синхронизацию сами и не нуждаются в 
помощи клиента.

### 2.1.1. Пример: сервлет без поддержки внутреннего состояния
```java
@ThreadSafe
public class StatelessFactorizer implements Servlet {
    public void service(ServletRequest req, ServletResponse resp) {
      BigInteger i = extractFromRequest(req);
      BigInteger[] factors = factor(i);
      encodeIntoResponse(resp, factors);
    }
}
```

Объекты без поддержки внутреннего состояния всегда являются потокобезопасными

## 2.2. Атомарноть

Сервлет, подсчитывающий запросы без необходимой
синхронизации. Так делать не следует

```java
@NotThreadSafe
public class UnsafeCountingFactorizer implements Servlet {
  private long count = 0;
  public long getCount() { return count; }
  public void service(ServletRequest req, ServletResponse resp) {
      BigInteger i = extractFromRequest(req);
      BigInteger[] factors = factor(i);
      ++count;
      encodeIntoResponse(resp, factors);
    }
}
```

Хотя операция приращения **++count** имеет компактный синтаксис, она не является атомарной 
(atomic), то есть неделимой, а представляет собой последовательность из трех операций: «прочитать,
изменить, записать»

### 2.2.1. Состояние гонки

Наиболее распространенным типом состояния гонки является ситуация «проверить и затем 
действовать», где потенциально устаревшее наблюдение используется для принятия решения о том, что
делать дальше

### 2.2.2. Пример: состояние гонки в ленивой инициализации

```java
@NotThreadSafe
public class LazyInitRace {
  private ExpensiveObject instance = null;
  public ExpensiveObject getInstance() {
    if (instance == null)
      instance = new ExpensiveObject();
    return instance;
  }
}
```

Во время инициализации потока A, поток B может тоже начать инициализировать объект

### 2.2.3. Составные действия

Операции A и B являются атомарными, если, с точки зрения потока, выполняющего операцию A, 
операция B либо была целиком выполнена другим потоком, либо не выполнена даже частично.

Там, где это удобно, используйте существующие потокобезопасные объекты, такие как AtomicLong, 
для управления состоянием вашего класса. Возможные состояния существующих потокобезопасных 
объектов и их переходы в другие состояния легче поддерживать и проверять на потокобезопасность, 
нежели произвольные переменные состояния.

## 2.3. Блокировка

Сервлет, пытающийся кэшировать свой последний результат без адекватной атомарности. Так делать 
не следует

```java
@NotThreadSafe
public class UnsafeCachingFactorizer implements Servlet {
    private final AtomicReference<BigInteger> lastNumber
            = new AtomicReference<BigInteger>();
    private final AtomicReference<BigInteger[]> lastFactors
            = new AtomicReference<BigInteger[]>();
    public void service(ServletRequest req, ServletResponse resp) {
        BigInteger i = extractFromRequest(req);
        if (i.equals(lastNumber.get()))
            encodeIntoResponse(resp, lastFactors.get());
        else {
            BigInteger[] factors = factor(i);
            lastNumber.set(i);
            lastFactors.set(factors);
            encodeIntoResponse(resp, factors);
        }
    }
}
```

Когда в инварианте участвуют многочисленные переменные, поля не являются независимыми: значение 
одного ограничивает допустимые значения другого. Следовательно, при обновлении одного необходимо 
обновлять другие в той же атомарной операции.

Для сохранения непротиворечивости состояний обновляйте родственные переменные состояния в единой 
атомарной операции.

### 2.3.1. Внутренние замки

синхронизированный блок, состоящий из ссылки на объект-замок (lock), и блока кода, который будет 
им защищен.

```java
synchronized (lock) {
 // Обратиться к защищаемому замком совместному состоянию либо его
 // изменить
}
```

Внутренние замки в Java действуют как взаимоисключающие замки — мьютексы (mutual exclusion 
locks). Когда поток A пытается приобрести замок, которым владеет поток B, он должен ждать или 
блокировать продвижение до тех пор, пока B его не освободит. Если B не освободит замок никогда, 
то A будет ждать вечно.

Сервлет, кэширующий последний результат с неприемлемо
слабой конкурентностью. Так делать не следует

```java
ThreadSafe
public class SynchronizedFactorizer implements Servlet {
    @GuardedBy("this") private BigInteger lastNumber;
    @GuardedBy("this") private BigInteger[] lastFactors;
    public synchronized void service(ServletRequest req,
                                     ServletResponse resp) {
        BigInteger i = extractFromRequest(req);
        if (i.equals(lastNumber))
            encodeIntoResponse(resp, lastFactors);
        else {
            BigInteger[] factors = factor(i);
            lastNumber = i;
            lastFactors = factors;
            encodeIntoResponse(resp, factors);
        }
    }
}
```

### 2.3.2. Повторная входимость

Код, запертый взаимной блокировкой, так как внутренние замки не являются повторно входимыми

```java
public class Widget {
    public synchronized void doSomething() {
        ...
    }
}

public class LoggingWidget extends Widget {
    public synchronized void doSomething() {
        System.out.println(toString() + ": calling doSomething");
        super.doSomething();
    }
}
```

## 2.4. Защита состояния с помощью замков

Все обращения к мутируемой переменной состояния должны выполняться с удержанием одного и того же 
замка. Только тогда переменная защищена этим замком.

Каждая совместная мутируемая переменная должна быть защищена только одним замком. Дайте 
сопроводителям четкое понимание, какой это замок.

Для каждого инварианта, который включает более одной переменной, все переменные, участвующие в 
инварианте, должны быть защищены тем же замком.

## 2.5. Живучесть и производительность 


При реализации политики синхронизации не поддавайтесь искушению пожертвовать простотой (что 
может поставить безопасность под угрозу) ради производительности.

Избегайте удержания блокировки во время длительных вычислений или операций, таких как сетевой 
или консольный ввод‑вывод.

Эти два способа записи означают одно и то же:

```java
public void swap() {
   synchronized (this)
   {
       //...логика метода
   }
}

public synchronized void swap() {
    //...логика метода
}
```

Обновленный код, в котором кешируется последнее число и его делители с счетчиками для статистики

```java
@ThreadSafe
public class CachedFactorizer implements Servlet {
    @GuardedBy("this") private BigInteger lastNumber;
    @GuardedBy("this") private BigInteger[] lastFactors;
    @GuardedBy("this") private long hits;
    @GuardedBy("this") private long cacheHits;
    public synchronized long getHits() { return hits; }
    public synchronized double getCacheHitRatio() {
        return (double) cacheHits / (double) hits;
    }
    public void service(ServletRequest req, ServletResponse resp) {
        BigInteger i = extractFromRequest(req);
        BigInteger[] factors = null;
        synchronized (this) {
            ++hits;
            if (i.equals(lastNumber)) {
                ++cacheHits;
                factors = lastFactors.clone();
            }
        }
        if (factors == null) {
            factors = factor(i);
            synchronized (this) {
                lastNumber = i;
                lastFactors = factors.clone();
            }
        }
        encodeIntoResponse(resp, factors);
    }
}
```

# 3. Совместное использование объектов

Синхронизация также имеет еще один важный аспект: видимость памяти (memory visibility). Мы 
обеспечим потокам во время изменения объекта возможность видеть внесенные другим потоком 
изменения и опубликуем объекты с помощью синхронизации (явной или встроенной в библиотечные 
классы)

## 3.1. Видимость

Совместное использование переменных без синхронизации. Так делать не следует

```java
public class NoVisibility {
    private static boolean ready;
    private static int number;
    private static class ReaderThread extends Thread {
        public void run() {
            while (!ready)
                Thread.yield();
            System.out.println(number);
        }
    }
    public static void main(String[] args) {
        new ReaderThread().start();
        number = 42;
        ready = true;
    }
}
```

Без синхронизации компилятор, процессор и рабочая среда могут запутать порядок выполнения 
операций. Не стоит ожидать естественного порядка действий памяти в недостаточно 
синхронизированных многопоточных программах.

Нужно применять правильную синхронизацию, когда данные используются потоками совместно.

### 3.1.1 Устаревшие данные

Класс NoVisibility (3.1.) продемонстрировал один из путей появления устаревших данных (stale 
data), которые видит читающий поток, если синхронизация не используется всякий раз при обращении 
к переменной.

Устаревшие значения могут вызывать сбои в безопасности или жизнеспособности: неожиданные 
исключения, поврежденные структуры данных,неточные вычисления и бесконечные циклы.

Непотокобезопасный мутируемый держатель целого числа

```java
@NotThreadSafe
public class MutableInteger {
    private int value;
    public int get() { return value; }
    public void set(int value) { this.value = value; }
}
```

Потокобезопасный мутируемый держатель целого числа

```java
@ThreadSafe
public class SynchronizedInteger {
    @GuardedBy("this") private int value;
    public synchronized int get() { return value; }
    public synchronized void set(int value) { this.value = value; }
}
```

### 3.1.2. Неатомарные 64-разрядные операции

Если несколько одновременно записывают и считывают 64-разрядные переменные (long, double), то 
возможна ситуация когда можно получить верхние 32 бита одного значения и нижние 32 бита другого

### 3.1.3. Блокировка и видимость

Чтобы обеспечить видимость актуальных значений совместных волатильных переменных, 
синхронизируйте читающие и пишущие потоки на общем замке.

### 3.1.4. Волатильные переменные

Переменная volatile для компилятора и рабочей среды является совместной, то есть операции над 
ней не будут переупорядочены с другими операциями в памяти. Волатильные переменные не кэшируются 
в регистрах или кэшах, где данные скрыты от других процессоров, поэтому их чтение всегда 
возвращает самый последний результат операций записи.

На большинстве современных процессорных архитектур волатильные чтения ненамного дороже 
неволатильных

Используйте волатильные переменные только тогда, когда они упрощают реализацию и проверку 
политики синхронизации. И избегайте их использования, когда диагностика правильности требует 
утонченных рассуждений о видимости. Волатильные переменные должны обеспечивать видимость их 
собственного состояния, состояния объекта, на который они ссылаются, или важного события 
жизненного цикла (например, инициализации или выключения).

 Типичное использование волатильных переменных:

```java
volatile boolean asleep;
...
    while (!asleep)
        countSomeSheep();
```

Совет по отладке: в серверном приложении всегда указывайте переключатель командной строки JVM-
server во время вызова JVM даже для разработки и тестирования. Серверная JVM выполняет больше 
оптимизационных задач, чем клиентская JVM, например извлекает из цикла переменные, которые в нем 
не модифицируются. Код, который может показаться работающим в рабочей среде (клиентская JVM), 
может нарушиться в среде развертывания (серверная JVM). Если бы в листинге 3.4 мы забыли 
объявить переменную asleep как волатильную, то серверная JVM могла бы вынуть проверку из цикла 
(превратив его в бесконечный цикл), а клиентская JVM — не могла бы. Бесконечный цикл, который 
проявляется при разработке, стоит намного дешевле, чем тот, который обнаруживает себя в процессе 
эксплуатации кода.

Волатильные переменные удобны и часто используются в качестве флажка завершения, прерывания или 
статуса. Однако механизм volatile недостаточно силен, для того чтобы сделать операцию приращения 
(count++) атомарной в многопоточной среде. Поэтому:

Блокировка может гарантировать как видимость, так и атомарность, а волатильные переменные 
гарантируют только видимость.

Использование волатильных переменных оправданно при следующих
условиях:
- записи в переменную не зависят от ее текущего значения, либо есть гарантия, что значения
  переменной обновляются только одним потоком;
- переменная не участвует в инвариантах с другими переменными состояния;
- при обращении к переменной заранее не требуется блокировка.

## 3.2. Публикация и ускользание

Позволяем ускользнуть внутреннему мутируемому состоянию.
Так делать не следует

```java
class UnsafeStates {
    private String[] states = new String[] {
        "AK", "AL" ...
    };
    public String[] getStates() { return states; }
}
```

Любой вызывающий массив states элемент кода может изменить его содержимое. В данном случае 
предположительно приватный объект стал публичным.

Когда класс ThisEscape публикует слушателя EventListener, он неявно публикует и окаймляющий его 
экземпляр ThisEscape, потому что экземпляры внутреннего класса содержат скрытую ссылку на него.

Неявное разрешение ссылке this ускользнуть. 
Так делать не следует

```java
public class ThisEscape {
    public ThisEscape(EventSource source) {
        source.registerListener(
        new EventListener() {
            public void onEvent(Event e) {
                doSomething(e);
            }
         });
     }
}
```

### 3.2.1. Приемы безопасного конструирования

Не позволяйте ссылке this ускользнуть во время конструирования.

Объект находится в предсказуемом и непротиворечивом состоянии только при полноценности его 
конструктора. В противном случае возникает риск публикации неполно сконструированного объекта, 
даже если публикация является последней инструкцией в конструкторе. Объект с ускользнувшей 
ссылкой this считается ненадлежаще сконструированным

Не позволяйте ссылке this ускользнуть во время конструирования.

Ссылка this не должна ускользать из потока до тех пор, пока конструктор не возвратится. Ссылка 
this может храниться где-то конструктором, при условии что она не используется другим потоком до 
завершения конструирования.

Использование фабричного метода для предотвращения ускользания ссылки this во время 
конструирования

```java
public class SafeListener {
    private final EventListener listener;
    private SafeListener() {
        listener = new EventListener() {
            public void onEvent(Event e) {
                doSomething(e);
            }
        };
    }
    public static SafeListener newInstance(EventSource source) {
        SafeListener safe = new SafeListener();
        source.registerListener(safe.listener);
        return safe;
    }
}
```

## 3.3. Ограничение одним потоком

Сам язык не содержит механизмов ограничения объекта одним потоком. Такое ограничение станет 
элементом проекта вашей программы. Языковые и ядерные библиотеки предоставляют механизмы 
поддержки ограничения — локальные переменные и класс ThreadLocal, — но ответственность за их 
реализацию лежит на разработчике.

### 3.3.1. Узкоспециальное ограничение одним потоком

Более прочными формами ограничения одним потоком являются ограничение стеком и ThreadLocal.

### 3.3.2. Ограничение стеком

При ограничении стеком (stack confinement) объект может быть достигнут только через локальные 
переменные.

### 3.3.3. ThreadLocal

Класс ThreadLocal позволяет ассоциировать каждое значение в потоке с объектом, владеющим этим 
значением. Он предоставляет методы доступа get и set, поддерживающие отдельную копию значения 
для каждого потока, который его использует, поэтому get возвращает самое последнее значение, 
переданное в set из выполняющегося в настоящее время потока.

Используя класс ThreadLocal для хранения соединения JDBC, как в ConnectionHolder, вы обеспечите 
каждому потоку свое собственное соединение.


Использование класса ThreadLocal для ограничения одним потоком:

```java
private static ThreadLocal<Connection> connectionHolder = new ThreadLocal<Connection>() {
    public Connection initialValue() {
        return DriverManager.getConnection(DB_URL);
    }
};
public static Connection getConnection() {
    return connectionHolder.get();
}
```
Значения TreadLocal хранятся в самом объекте Thread, и когда поток терминируется, они могут быть
собраны сборщиком мусора.

## 3.4. Немутируемость

Немутируемые объекты всегда являются потокобезопасными.

### 3.4.1. Финальные поля

Объявляйте поля приватными, если они не нуждаются в большей видимости, и финальными — если они не
должны быть мутируемыми.

### 3.4.2 Пример: использование volatile для публикации немутируемых объектов

Немутируемый держатель для кэширования числа и его множителей

```java 
@Immutable
class OneValueCache {
    private final BigInteger lastNumber;
    private final BigInteger[] lastFactors;
    public OneValueCache(BigInteger i, BigInteger[] factors) {
        lastNumber = i;
        lastFactors = Arrays.copyOf(factors, factors.length);
    }
    public BigInteger[] getFactors(BigInteger i) {
        if (lastNumber == null || !lastNumber.equals(i))
            return null;
        else
            return Arrays.copyOf(lastFactors, lastFactors.length);
    }
}
```

Состояния гонки при доступе или обновлении родственных переменных могут быть устранены в 
немутируемом держателе даже без блокировки: когда поток приобретет на него ссылку, другой поток 
уже не сможет изменить его состояние. Чтобы обновить переменные, потребуется создать новый 
держатель, но потоки, работающие с предыдущим держателем, продолжат видеть его в непротиворечивом 
состоянии.

Кэширование последнего результата с помощью изменчивой ссылки на немутируемый держатель объекта

```java
@ThreadSafe
public class VolatileCachedFactorizer implements Servlet {
    private volatile OneValueCache cache = new OneValueCache(null, null);
    public void service(ServletRequest req, ServletResponse resp) {
        BigInteger i = extractFromRequest(req);
        BigInteger[] factors = cache.getFactors(i);
        if (factors == null) {
            factors = factor(i);
            cache = new OneValueCache(i, factors);
        }
        encodeIntoResponse(resp, factors);
    }
}
```

## 3.5. Безопасная публикация

Публикация объекта без надлежащей синхронизации. Так делать не следует

```java
// Небезопасная публикация
public Holder holder;
public void initialize() {
    holder = new Holder(42);
}
```

Вы будете удивлены, но из‑за проблем видимости держатель Holder может показаться другому потоку в 
противоречивом состоянии, даже если его инварианты были правильно установлены его конструктором! 
Именно ненадлежащая публикация заставит другой поток наблюдать частично сконструированный объект.

### 3.5.1. Ненадлежащая публикация: хорошие объекты становятся плохими

Не стоит надеяться на целостность частично сконструированных объектов. Наблюдающий поток может 
увидеть сначала объект в противоречивом состоянии, а затем внезапное изменение состояния. Если 
держатель Holder будет опубликован так, как в 3.5., при вызове метода assertSanity 
возникнет ошибка AssertionError!

Риск возникновения сбоя при ненадлежащей публикации

```java
public class Holder {
    private int n;
    public Holder(int n) { this.n = n; }
    public void assertSanity() {
        if (n != n)
            throw new AssertionError("Эта инструкция является ложной.");
    }
}
```

Проблема здесь не в самом классе Holder, а в его публикации. Holder может быть сделан 
невосприимчивым к ненадлежащей публикации, если объявить поле n финальным, что сделает класс 
Holder немутируемым

Поскольку синхронизация не использовалась для того, чтобы сделать класс Holder видимым для других 
потоков, другие потоки увидят либо устаревшее значение в поле holder (пустую ссылку null или 
другое), либо актуальное значение ссылки на holder, но устаревшие значения состояния Holder, либо 
устаревшее значение при первом чтении поля, а в следующий раз — более актуальное значение. 

Да, без достаточной синхронизации могут происходить очень странные вещи, если данные используются 
потоками совместно.

### 3.5.2. Немутируемые объекты и безопасность при инициализации

Немутируемые объекты могут безопасно использоваться потоками без дополнительной синхронизации, 
даже когда синхронизация для их публикации не используется.

### 3.5.3. Приемы безопасной публикации

Безопасную публикацию объекта, при которой ссылка на него и его состояние видна всем потокам в 
одно и то же время, можно провести с помощью:
- инициализации объектной ссылки из статического инициализатора;
- сохранения ссылки на него в волатильном поле либо в AtomicReference;
- сохранения ссылки на него в финальном поле надлежаще сконструированного объекта;
- сохранения ссылки на него в поле, которое надлежаще защищается замком.

Потокобезопасные библиотечные коллекции предлагают следующие гарантии безопасной публикации:
- ключ или значение, размещенные в Hashtable, synchronizedMap либо
  ConcurrentMap, безопасно публикуются в любом потоке, который извлекает их из ассоциативного
  массива Map (напрямую или через итератор);
- элемент, размещенный в Vector, CopyOnWriteArrayList, CopyOnWriteArraySet, synchronizedList либо
  synchronizedSet, безопасно публикуется в любом потоке, который извлекает его из коллекции;
- элемент, размещенный в BlockingQueue либо ConcurrentLinkedQueue, безопасно публикуется в любом
  потоке, который извлекает его из очереди.

### 3.5.4. Фактически немутируемые объекты

Объекты, которые не являются немутируемыми, но состояние которых не будет изменено после 
публикации, называются фактически немутируемыми (effectively immutable).

Безопасно опубликованные фактически немутируемые объекты могут безопасно использоваться любым 
потоком без дополнительной синхронизации.

### 3.5.5. Мутируемые объекты

Требования к публикации объекта зависят от его мутируемости:
- немутируемые объекты могут быть опубликованы любым механизмом;
- фактически немутируемые объекты должны быть безопасно опубликованы;
- мутируемые объекты должны быть безопасно опубликованы и быть либо потокобезопасными, либо
  защищенными замком.

### 3.5.6. Безопасное совместное использование объектов

Ниже приведены наиболее полезные политики для применения и совместного использования объектов в 
конкурентной программе: 
**Ограничение одним потоком.** Объект, ограниченный одним потоком, принадлежит эксклюзивно 
владеющему потоку, который может его изменять.

**Совместный доступ только для чтения.** Потоки могут обращаться к объекту, предназначенному 
только для чтения, конкурентно, без дополнительной синхронизации и возможности его изменять. 
Совместные объекты только для чтения включают немутируемые и фактически немутируемые объекты.

**Совместная потокобезопасность.** Потокобезопасный объект выполняет синхронизацию внутренне, 
поэтому потоки могут свободно обращаться к нему через его публичный интерфейс без дополнительной 
синхронизации.

**Защищенность.** С удержанием конкретного замка можно обращаться к объекту, инкапсулированному в 
другие потокобезопасные объекты, а также к опубликованному объекту, защищенному замком.

# 4. Компоновка объектов

В этой главе мы рассмотрим паттерны для безопасного структурирования классов.

## 4.1. Проектирование потокобезопасного класса

Проектирование потокобезопасного класса включает три этапа:
- идентификация переменных, формирующих состояние объекта;
- идентификация инвариантов, ограничивающих переменные состояния;
- создание политики для управления конкурентным доступом к состоянию объекта.

Простой потокобезопасный счетчик с использованием Java паттерна — монитор

```java
@ThreadSafe
public final class Counter {
    @GuardedBy("this") private long value = 0;
    public synchronized long getValue() {
        return value;
    }
    public synchronized long increment() {
        if (value == Long.MAX_VALUE)
            throw new IllegalStateException("переполнение счетчика");
        return ++value;
     }
}
```

### 4.1.1. Сбор требований к синхронизации

Многие классы имеют инварианты, идентифицирующие состояния как допустимые (valid) или 
недопустимые (invalid). Поле value в Counter имеет тип long. Состояние пространства типа long 
находится в диапазоне от Long.MIN_VALUE до Long.MAX_VALUE, но Counter ограничивает value только 
положительными значениями. 

Постусловия в операциях могут идентифицировать переход из состояния в состояние (state 
transitions) как недопустимый. Если текущее состояние объекта Counter равно 17, то единственным 
допустимым следующим состоянием должно быть 18.

Обеспечивайте потокобезопасность, учитывая роль инвариантов и постусловий. 

### 4.1.2. Операции, зависимые от состояния

Некоторые объекты имеют методы с предусловиями, основанными на состоянии. Предусловия, например, 
запрещают удалять элемент из пустой очереди, требуя для удаления состояние очереди «не пусто». 
Операции с предусловиями, основанными на состоянии, именуются зависимыми от состояния (state-
dependent)

Если в однопоточной программе предусловие не соблюдается, то операция завершается 
безрезультатно. Конкурентные же программы ожидают появление потока, для которого предусловие 
станет истинным, и затем продолжают выполнение операции. (wait и notify)

### 4.1.3. Владение состоянием

При определении переменных, формирующих состояние объекта, мы учитываем только те данные, которыми 
объект владеет. Владение не воплощено в языке явным образом, а является элементом проектирования 
класса.

Во многих случаях владение связано с инкапсуляцией — объект инкапсулирует состояние, которым владеет, 
и владеет состоянием, которое инкапсулирует. Именно владелец переменной состояния принимает решение о 
замковом протоколе, используемом для поддержания целостности ее состояния. Из факта владения вытекает 
обязанность контроля, которая после публикации ссылки на мутируемый объект приобретет совместный 
характер. Класс не владеет объектами, поставляемыми в его методы или конструкторы, если сам метод не 
предназначен для явной передачи права владения.

## 4.2. Ограничение одним экземпляром

Инкапсуляция данных в объекте ограничивает доступ к ним только методами объекта, что упрощает 
обеспечение постоянного доступа с удержанием замка.

Использование ограничения одним экземпляром

```java
@ThreadSafe
public class PersonSet {
    @GuardedBy("this")
    private final Set<Person> mySet = new HashSet<Person>();
    public synchronized void addPerson(Person p) {
        mySet.add(p);
    }
    public synchronized boolean containsPerson(Person p) {
        return mySet.contains(p);
    }
}
```

Ограничение одним экземпляром (synchronized) упрощает создание потокобезопасных классов, позволяя 
анализировать их потокобезопасность без проверки всей программы.

### 4.2.1. Мониторный шаблон Java

По принципу ограничения одним экземпляром работает и мониторный шаблон Java (Java monitor pattern)1: 
объект, подчиняющийся шаблону, инкапсулирует мутируемое состояние под защитой внутреннего замка.

Защита состояния с помощью приватного замка

```java
public class PrivateLock {
    private final Object myLock = new Object();
    @GuardedBy("myLock") Widget widget;
    void someMethod() {
        synchronized(myLock) {
            // Обратиться и изменить состояние виджета
        }
    }
}
```

Преимущество использования приватного замка — в его инкапсуляции, которая не позволяет клиентскому 
коду приобрести его и участвовать в политике его синхронизации, избавляя от необходимости проверки 
всей программы.

### 4.2.2. Пример: трекинг такси

Наш трекер такси будет программой для диспетчера таксопарка. Сначала мы построим его с помощью 
мониторного шаблона, а затем ослабим требования к инкапсуляции, сохраняя потокобезопасность.

Каждое такси будет идентифицироваться объектом String и иметь местоположение в координатах (x, y). 
Классы VehicleTracker инкапсулируют идентичность и местоположения известных такси

Просмотровый поток будет доставлять имена и местоположения такси и выводить их на дисплей:

```java
Map<String, Point> locations = vehicles.getLocations();
for (String key : locations.keySet())
    renderVehicle(key, locations.get(key));
```

Так же изменение координат:

```java
void vehicleMoved(VehicleMovedEvent evt) {
    Point loc = evt.getNewLocation();
    vehicles.setLocation(evt.getVehicleId(), loc.x, loc.y);
}
```

Потоки будут обращаться к модели данных конкурентно, и она должна быть потокобезопасной.
(Сам пример будет описан в последующих главах)

### 4.3. Делегирование потокобезопасности

Мониторная реализация трекера такси

```java
@ThreadSafe
public class MonitorVehicleTracker {
    @GuardedBy("this")
    private final Map<String, MutablePoint> locations;
    public MonitorVehicleTracker( Map<String, MutablePoint> locations) {
        this.locations = deepCopy(locations);
    }
    public synchronized Map<String, MutablePoint> getLocations() {
        return deepCopy(locations);
    }
    public synchronized MutablePoint getLocation(String id) {
        MutablePoint loc = locations.get(id);
        return loc == null ? null : new MutablePoint(loc);
    }
    public synchronized void setLocation(String id, int x, int y) {
        MutablePoint loc = locations.get(id);
        if (loc == null) throw new IllegalArgumentException("No such ID: " + id);
        loc.x = x;
        loc.y = y;
    }
    private static Map<String, MutablePoint> deepCopy(Map<String, MutablePoint> m) {
        Map<String, MutablePoint> result = new HashMap<String, MutablePoint>();
        for (String id : m.keySet()) result.put(id, new MutablePoint(m.get(id)));
        return Collections.unmodifiableMap(result);
    }
}
// Изменяемый класс точки, подобный java.awt.Point
@NotThreadSafe
public class MutablePoint {
    public int x, y;
    public MutablePoint() { x = 0; y = 0; }
    public MutablePoint(MutablePoint p) {
        this.x = p.x;
        this.y = p.y;
    }
}
```

### 4.3.1. Пример: трекер такси с использованием делегирования

Давайте сконструируем версию трекера такси, которая делегирует свои обязанности по потокобезопасности 
неизменяемому классу. Местоположения хранятся в ассоциативном массиве Map, поэтому мы начнем с 
потокобезопасной реализации хеш-массива ConcurrentHashMap.

Неизменяемый класс точки Point, используемый трекером DelegatingVehicleTracker

```java
@Immutable
public class Point {
    public final int x, y;
    public Point(int x, int y) {
        this.x = x;
        this.y = y;
    }
}
```

Класс Point является потокобезопасным, поэтому нам больше не нужно копировать местоположения при их 
возврате.

Делегирование потокобезопасности в хеш-массив ConcurrentHashMap

```java
@ThreadSafe
public class DelegatingVehicleTracker {
    private final ConcurrentMap<String, Point> locations;
    private final Map<String, Point> unmodifiableMap;
    public DelegatingVehicleTracker(Map<String, Point> points) {
        locations = new ConcurrentHashMap<String, Point>(points);
        unmodifiableMap = Collections.unmodifiableMap(locations);
    }
    public Map<String, Point> getLocations() {
        return unmodifiableMap;
    }
    public Point getLocation(String id) {
        return locations.get(id);
    }
    public void setLocation(String id, int x, int y) {
        if (locations.replace(id, new Point(x, y)) == null)
            throw new IllegalArgumentException("недопустимое имя такси: " + id);
    }
}
```

Обратите внимание, что мы немного изменили поведение класса трекера такси: мониторная версия 
возвращала снимок местоположений, а делегирующая версия возвращает их неизменяемое, но «живое» 
представление. Это означает, что если поток A вызывает метод getLocations, а поток B позже изменяет 
местоположение некоторых точек, эти изменения отражаются в хеш-массиве, возвращенном потоку A. Как мы 
отмечали ранее, это может быть преимуществом (более актуальные данные) либо недостатком (потенциально 
противоречивое представление таксопарка), в зависимости от ваших требований.

Если требуется неизменное представление парка, то метод getLocations может вернуть неглубокую копию 
хеш-массива местоположений.

### 4.3.2. Независимые переменные состояния

Делегировать потокобезопасность более чем одной базовой переменной состояния возможно, если эти 
переменные независимы, то есть композитный класс не накладывает инварианты с их участием.

Делегирование потокобезопасности нескольким базовым переменным состояния

```java
public class VisualComponent {
    private final List<KeyListener> keyListeners = new CopyOnWriteArrayList<KeyListener>();
    private final List<MouseListener> mouseListeners = new CopyOnWriteArrayList<MouseListener>();
    public void addKeyListener(KeyListener listener) {
        keyListeners.add(listener);
    }
    public void addMouseListener(MouseListener listener) {
        mouseListeners.add(listener);
    }
    public void removeKeyListener(KeyListener listener) {
        keyListeners.remove(listener);
    }
    public void removeMouseListener(MouseListener listener) {
        mouseListeners.remove(listener);
    }
}
```

Каждый список является потокобезопасным, и поскольку нет ограничений между их состояниями, 
VisualComponent может делегировать свои обязанности по потокобезопасности базовым объектам 
mouseListeners и keyListeners.

### 4.3.3. Случаи безуспешного делегирования

Класс диапазона чисел, недостаточно защищающий свои инварианты. Так делать не следует

```java
public class NumberRange {
    // ИНВАРИАНТ: lower <= upper
    private final AtomicInteger lower = new AtomicInteger(0);
    private final AtomicInteger upper = new AtomicInteger(0);
    public void setLower(int i) {
        // Предупреждение – небезопасная операция "проверить и затем действовать"
        if (i > upper.get()) 
            throw new IllegalArgumentException("не могу установить lower равным " + i + " > upper");
        lower.set(i);
    }
    public void setUpper(int i) {
        // Предупреждение – небезопасная операция "проверить и затем действовать"
        if (i < lower.get()) 
            throw new IllegalArgumentException("не могу установить upper равным " + i + " < lower");
        upper.set(i);
    }
    public boolean isInRange(int i) {
        return (i >= lower.get() && i <= upper.get());
    }
}
```
Класс NumberRange не является потокобезопасным: он не соблюдает инвариант, который ограничивает lower 
и upper. Методы setLower и setUpper пытаются соблюсти этот инвариант, но безуспешно, так как являются 
последовательностями операций «проверить и затем действовать», но их блокировка не обеспечивает им 
атомарности. Если в диапазоне (0, 10) один поток вызовет setLower(5), а другой в то же время — 
setUpper(4), то при неудачной временнˆой координации оба потока пройдут проверку в методах доступа 
set, и выполнятся два изменения, создав диапазон (5, 4) — недопустимое состояние.

Потокобезопасность класса NumberRange может обеспечить блокировка, которая сохранит его инварианты и 
защитит lower и upper замком, чтобы препятствовать их публикации.

### 4.3.4. Публикация базовых переменных состояния

Если переменная состояния является потокобезопасной, не участвует в инвариантах, ограничивающих ее 
значение, и не имеет запрещенных переходов из состояния в состояние для любой из ее операций, то она 
может быть безопасно опубликована.

### 4.3.5. Пример: трекер такси, публикующий свое состояние

Рассмотрим версию трекера такси с публикацией базового мутируемого состояния путем размещения на 
мутируемых, но потокобезопасных точках.

Класс потокобезопасной мутируемой точки

```java
@ThreadSafe
public class SafePoint {
    @GuardedBy("this") private int x, y;
    private SafePoint(int[] a) { this(a[0], a[1]); }
    public SafePoint(SafePoint p) { this(p.get()); }
    public SafePoint(int x, int y) {
        this.x = x;
        this.y = y;
    }
    public synchronized int[] get() {
        return new int[] { x, y };
    }
    public synchronized void set(int x, int y) {
        this.x = x;
        this.y = y;
    }
}
```

Приватный конструктор существует для того, чтобы избежать состояния гонки, возникающего при 
реализации конструктора копирования, такого как this(p.x, p.y); это пример захвата частного 
конструктора а (private constructorcapture)

Класс SafePoint в листинге 4.11 предоставляет метод доступа get, который извлекает значения x и y 
одновременно, возвращая двухэлементный массив1 . Наличие двух отдельных методов get для x и y 
заставило бы вызывающий элемент кода видеть противоречивое значение.

Трекер такси, безопасно публикующий базовое состояние

```java
@ThreadSafe
public class PublishingVehicleTracker {
    private final Map<String, SafePoint> locations;
    private final Map<String, SafePoint> unmodifiableMap;
    public PublishingVehicleTracker(Map<String, SafePoint> locations) {
        this.locations = new ConcurrentHashMap<String, SafePoint>(locations);
        this.unmodifiableMap = Collections.unmodifiableMap(this.locations);
    }
    public Map<String, SafePoint> getLocations() {
        return unmodifiableMap;
    }
    public SafePoint getLocation(String id) {
        return locations.get(id);
    }
    public void setLocation(String id, int x, int y) {
        if (!locations.containsKey(id))
            throw new IllegalArgumentException("недопустимое имя транспортного средства: " + id);
         locations.get(id).set(x, y);
    }
}
```

Вызывающие элементы кода не могут добавлять или удалять такси, но могут изменять местоположение 
одного из них путем мутирования значений SafePoint в возвращенном ассоциативном массиве Map. «Живой» 
характер ассоциативного массива Map может быть преимуществом либо недостатком, в зависимости от 
требований.

## 4.4. Добавление функциональности в существующие потокобезопасные классы

Чтобы создать потокобезопасный список с атомарной операцией «добавить, если отсутствует», нам 
потребуется синхронизированный список List, который предоставляет методы contains и add.

Самый безопасный способ добавить атомарную операцию — это изменить класс таким образом, чтобы он 
начал ее поддерживать. Мы не всегда имеем доступ к исходному коду, однако, если мы его получили, нам 
нужно понимать принятую в коде политику синхронизации, которая контролируется в одном исходном файле. 
Можно расширить класс (предназначенный для расширения). Класс BetterVector расширяет класс Vector, 
добавляя метод putIfAbsent.

Расширение класса Vector для использования метода «добавить, если отсутствует»

```java
@ThreadSafe
public class BetterVector<E> extends Vector<E> {
    public synchronized boolean putIfAbsent(E x) {
        boolean absent = !contains(x);
        if (absent) add(x);
        return absent;
     }
}
```

### 4.4.1. Блокировка на стороне клиента

Непотокобезопасная попытка реализовать метод «добавить, если отсутствует». Так делать не следует

```java
@NotThreadSafe
public class ListHelper<E> {
    public List<E> list = Collections.synchronizedList(new ArrayList<E>());
    ...
    public synchronized boolean putIfAbsent(E x) {
        boolean absent = !list.contains(x);
        if (absent) list.add(x);
        return absent;
    }
}
```

Метод putIfAbsent синхронизирован? Да, но на неправильном замке. Класс ListHelper обеспечивает только 
иллюзию синхронизации: на самом деле операции используют разные замки, и метод putIfAbsent не 
воспринимается другими операциями как атомарный.

Исправить этот пример поможет блокировка на стороне клиента (clientside locking) или внешняя 
блокировка.

Реализация метода «добавить, если отсутствует» с блокировкой на стороне клиента

```java
@ThreadSafe
public class ListHelper<E> {
    public List<E> list = Collections.synchronizedList(new ArrayList<E>());
    ...
    public boolean putIfAbsent(E x) {
        synchronized (list) {
            boolean absent = !list.contains(x);
            if (absent) list.add(x);
            return absent;
        }
    }
}
```

В то время как расширение класса нарушает инкапсуляцию реализации, блокировка на стороне клиента 
нарушает инкапсуляцию политики синхронизации.

### 4.4.2. Компоновка

Добавить атомарную операцию в существующий класс поможет компоновка (composition).

Реализация метода «добавить, если отсутствует» с использованием компоновки

```java
@ThreadSafe
public class ImprovedList<T> implements List<T> {
    private final List<T> list;
    public ImprovedList(List<T> list) { this.list = list; }
    public synchronized boolean putIfAbsent(T x) {
        boolean contains = list.contains(x);
        if (contains) list.add(x);
        return !contains;
    }
    public synchronized void clear() { list.clear(); }
    // ... делегировать остальные списковые методы схожим образом
}
```

Класс ImprovedList добавляет новый уровень блокировки с помощью своего внутреннего замка, не обращая 
внимания на наличие или отсутствие потокобезопасности у List. Дополнительная синхронизация может 
наложить штраф на производительность, но такое использование мониторного шаблона Java для 
инкапсуляции существующего списка гарантированно обеспечит потокобезопасность, при условии что класс 
содержит единственную ожидающую обработки ссылку на базовый список.

## 4.5. Документирование политик синхронизации

Документируйте гарантии потокобезопасности класса для клиентов и политику синхронизации — для 
сопроводителей. 

### 4.5.1. Толкование расплывчатой документации

Спецификации технологии Java мало сообщают о гарантиях потокобезопасности и требованиях к 
интерфейсам, таким как ServletContext, HttpSession и DataSource. Поскольку эти интерфейсы реализуются 
поставщиком контейнера или базы данных, часто невозможно просмотреть их код. И что же нам делать?

Догадываться. Интерпретировать спецификацию с точки зрения того, кто будет ее реализовывать.

# 5 Строительные блоки

В предыдущей главе мы описали несколько технических решений для конструирования потокобезопасных 
классов. Эта глава посвящена использованию конкурентных строительных блоков, таких как коллекции и 
синхронизаторы.

## 5.1. Синхронизированные коллекции 

К синхронизированным классам коллекций (synchronized collection classes) относятся Vector и 
Hashtable, часть исходного JDK, а также добавленные в JDK 1.2 синхронизированные оберточные классы, 
создаваемые фабричными методами Collections.synchronizedXxx. Эти классы обеспечивают 
потокобезопасность, инкапсулируя свое состояние и синхронизуя каждый публичный метод таким образом, 
чтобы только один поток за один раз мог обратиться к состоянию коллекции.

### 5.1.1. Проблемы синхронизированных коллекций

Синхронизированные коллекции являются потокобезопасными, но, когда потоки имеют возможность 
конкурентно изменять коллекцию, требуется блокировка на стороне клиента для защиты составных 
действий. Такие действия включают итеративный обход (доставку элементов из коллекции), навигацию 
(отыскание следующего элемента) и условные операции (связывание ключа K с неким значением).

Составные действия над объектом Vector, приводящие к запутанным результатам

```java
public static Object getLast(Vector list) {
    int lastIndex = list.size() - 1;
    return list.get(lastIndex);
}
public static void deleteLast(Vector list) {
    int lastIndex = list.size() - 1;
    list.remove(lastIndex);
}
```

Сами методы не могут повредить Vector — опасен элемент кода, вызывающий их. Если поток A вызывает 
метод getLast, а поток B — метод deleteLast, то эти операции перемежаются и метод getLast выдает 
исключение ArrayIndexOutOfBoundsException. Между вызовом метода size и последующим вызовом метода 
getlast объект Vector сжимается и индекс, вычисленный на первом шаге, перестает быть допустимым.

Составные действия над объектом Vector с использованием блокировки на стороне клиента

```java
public static Object getLast(Vector list) {
    synchronized (list) {
        int lastIndex = list.size() - 1;
        return list.get(lastIndex);
    }
}
public static void deleteLast(Vector list) {
    synchronized (list) {
        int lastIndex = list.size() - 1;
        list.remove(lastIndex);
    }
}
```

Итеративный обход, который может выдавать исключение ArrayIndexOutOfBoundsException

```java
for (int i = 0; i < vector.size(); i++)
    doSomething(vector.get(i));
```

Блокировка на стороне клиента влияет на масштабируемость. В течение всего времени итеративного обхода 
владея замком на Vector, мы не позволяем другим потокам изменять его. К сожалению, от этого страдает 
конкурентность.

Итеративный обход с блокировкой на стороне клиента

```java
synchronized (vector) {
    for (int i = 0; i < vector.size(); i++)
        doSomething(vector.get(i));
}
```

### 5.1.2. Итераторы и исключение ConcurrentModificationException

Ниже показан итеративный обход коллекции с использованием синтаксиса цикла for-each. javac генерирует 
код, который использует итератор, многократно вызывая hasNext и next. Чтобы предотвратить исключение 
ConcurrentModificationException, надо владеть коллекционным замком в течение **всего** времени 
итеративного обхода.

Итеративный обход списка с помощью итератора

```java
List<Widget> widgetList= Collections.synchronizedList(new ArrayList<Widget>());
...
// Может выдать ConcurrentModificationException
for (Widget w : widgetList)
    doSomething(w);
```

Однако блокировка коллекции во время итеративного обхода не всегда уместна. При больших коллекциях и 
задачах ожидание завершения итерации становится слишком долгим.

Любое запирание коллекций на значительные периоды времени снижает масштабируемость приложения: чем 
дольше замок занят, тем больше вероятность того, что он будет оспариваться другими потоками

Альтернативой запиранию коллекции во время итеративного обхода является ее клонирование и итеративный 
обход клона. Клон ограничен одним потоком, но коллекция все равно должна быть защищена замком во 
время клонирования. Насколько клонирование оправданно, зависит от размера коллекции, объема работы, 
выполняемой для каждого элемента, относительной частоты итераций, а также требований к отзывчивости и 
пропускной способности. 

### 5.1.3. Скрытые итераторы

Использовать блокировку везде, где может выполняться итеративный обход совместной коллекции, не так 
просто. Итераторы бывают скрытыми, как в HiddenIterator в листинге 5.6, где явного итеративного 
обхода нет, но код, выделенный жирным шрифтом, его подразумевает. Конкатенация строк преобразуется 
компилятором в вызов StringBuilder.append(Object), который, в свою очередь, активирует метод 
toString, который в стандартных коллекциях выполняет итеративный обход.

Итеративный обход, скрытый внутри конкатенации строк. Так делать не следует

```java
public class HiddenIterator {
    @GuardedBy("this") private final Set<Integer> set = new HashSet<Integer>();
    public synchronized void add(Integer i) { set.add(i); }
    public synchronized void remove(Integer i) { set.remove(i); }
    public void addTenThings() {
        Random r = new Random();
        for (int i = 0; i < 10; i++)
            add(r.nextInt());
        System.out.println("ОТЛАДКА: добавлено десять элементов в " + set);
    }
}
```

Итеративный обход также косвенно активируется коллекционными методами hashCode и equals, которые 
могут вызываться, если коллекция используется в качестве элемента или ключа другой коллекции.

## 5.2. Конкурентные коллекции

Синхронизированные коллекции обеспечивают потокобезопасность, сериализуя весь доступ к своему 
состоянию. Стоимость этого подхода равна слабой конкурентности. Совершенствуя синхронизированные 
коллекции, Java предоставляет несколько конкурентных коллекционных классов.

Версия предлагает хеш-массив ConcurrentHashMap вместо синхронизированных хешированных реализаций 
ассоциативного массива Map, и CopyOnWriteArrayList вместо синхронизированных реализаций списка List 
для случаев, где обход является доминирующей операцией. Новый интерфейс ассоциативного массива 
ConcurrentMap поддерживает распространенные составные действия, такие как операция «добавить, если 
отсутствует», замена и условное удаление

Замена синхронизированных коллекций конкурентными коллекциями может предложить значительные улучшения 
масштабируемости при небольшом риске.

### 5.2.1. ConcurrentHashMap

Класс ConcurrentHashMap — это хешированный ассоциативный массив Map, аналогичный хеш-массиву HashMap, 
но использующий другую замковую стратегию. Вместо синхронизации каждого метода на общем замке и 
ограничения доступа одним потоком за раз он использует замковое расщепление на полосы (lock striping, 
см. раздел 11.4.3), расширяющее возможности совместного доступа к ассоциативному массиву. Оно 
обеспечивает конкурентность между читающими потоками, между читателями и писателями и между 
писателями. Результатом является высокая пропускная способность в рамках конкурентного доступа с 
небольшим штрафом на производительность для однопоточного доступа.

Также класс ConcurrentHashMap предоставляет итераторы, которые не выдают исключение 
ConcurrentModificationException, являются не быстро отказывающими, а слабо непротиворечивыми (weakly 
consistent). Они допускают конкурентное выполнение изменений, перебирают элементы в том порядке, в 
каком они существовали при конструировании итератора, и могут (не обязательно) отражать изменения в 
коллекцию.

### 5.2.2. Дополнительные атомарные операции над ассоциативным массивом

Поскольку хеш-массив ConcurrentHashMap не заперт для эксклюзивного доступа, мы не можем использовать 
блокировку на стороне клиента для создания новых атомарных операций как в разделе 4.4.1. Однако ряд 
составных операций («добавить, если отсутствует», «удалить, если равно» и «заменить, если равно») 
сразу задаются интерфейсом ConcurrentMap как атомарные.

Интерфейс ConcurrentMap

```java
public interface ConcurrentMap<K,V> extends Map<K,V> {
    // Вставить в ассоциативный массив, только если ни одно значение не соответствует ключу K
    V putIfAbsent(K key, V value);
    // Удалить, только если ключу K соответствует значение V
    boolean remove(K key, V value);
    // Заменить значение, только если ключу K соответствует старое значение oldValue
    boolean replace(K key, V oldValue, V newValue);
    // Заменить значение, только если ключу K соответствует некое значение
    V replace(K key, V newValue);
}
```

### 5.2.3. CopyOnWriteArrayList 

Класс CopyOnWriteArrayList является конкурентной версией синхронизированного спискового класса List, 
который предлагает более высокую конкурентность и устраняет необходимость в блокировке или 
клонировании коллекции во время итеративного обхода.

Очевидно, что копирование резервного массива сопряжено с определенной стоимостью, и его целесообразно 
использовать только тогда, когда итеративный обход встречается гораздо чаще, чем изменение. Например, 
доставка уведомления требует итеративного обхода списка зарегистрированных слушателей и вызова 
каждого из них, а регистрация или дерегистрация слушателей происходят гораздо реже.

Итераторы CopyOnWriteArrayList сохраняют ссылку на резервный массив, который был актуальным в начале 
итеративного обхода, и так как он никогда не изменяется, синхронизация им нужна ненадолго — чтобы 
обеспечить видимость содержимого массива. Потоки могут выполнять итеративный обход коллекции, не 
мешая потокам, желающим изменить ее. Итераторы не выдают исключения ConcurrentModificationException и 
возвращают элементы, не измененные с момента создания итератора.

### 5.3. Блокирующие очереди и паттерн «производитель-потребитель»

Блокирующие очереди поддерживают паттерн проектирования произ‑ водитель-потребитель (producer-
consumer), который помещает рабочие элементы в список предстоящих дел для последующей обработки, 
вместо того чтобы обрабатывать их сразу по мере их идентификации.

Ограниченные очереди делают вашу программу устойчивой к перегрузке

Встраивайте управление ресурсами в проект с помощью блокирующих очередей, причем гораздо проще делать 
это заранее, чем модернизировать код позже.

### 5.3.1. Пример: поиск на рабочем столе

Разложим на производителей и потребителей работу агента, который сканирует локальные диски на наличие 
документов и индексирует их для последующего поиска

Разложение обхода файлов и индексации на отдельные действия приводит к лучшей читаемости кода. 
Производитель и потребитель могут выполняться конкурентно: если один привязан к вводу-выводу, а 
другой — к процессору, то конкурентное их выполнение даст более высокую совокупную пропускную 
способность, чем последовательное.

Задачи производителя и потребителя в настольном поисковом приложении

```java
public class FileCrawler implements Runnable {
    private final BlockingQueue<File> fileQueue;
    private final FileFilter fileFilter;
    private final File root;
    public void run() {
        try {
            crawl(root);
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
    }
    private void crawl(File root) throws InterruptedException {
        File[] entries = root.listFiles(fileFilter);
        if (entries != null) {
            for (File entry : entries)
                if (entry.isDirectory())
                    crawl(entry);
                else if (!alreadyIndexed(entry))
                    fileQueue.put(entry);
        }
    }
}
public class Indexer implements Runnable {
    private final BlockingQueue<File> queue;
    public Indexer(BlockingQueue<File> queue) {
        this.queue = queue;
    }
    public void run() {
        try {
            while (true)
                indexFile(queue.take());
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
    }    
}
```

Запуск поиска на рабочем столе

```java
public static void startIndexing(File[] roots) {
    BlockingQueue<File> queue = new LinkedBlockingQueue<File>(BOUND);
    FileFilter filter = new FileFilter() {
        public boolean accept(File file) { return true; }
    };
    for (File root : roots) new Thread(new FileCrawler(queue, filter, root)).start();
    for (int i = 0; i < N_CONSUMERS; i++)
        new Thread(new Indexer(queue)).start();
}
```

### 5.3.2. Серийное ограничение одним потоком

Паттерны «производитель-потребитель» и блокирующие очереди поддерживают серийное ограничение одним 
потоком (serial thread confinement) мутируемых объектов. Эксклюзивное владение объектом может быть 
«перенесено» другому потоку путем безопасной публикации. Исходный владелец не будет касаться объекта 
снова, а новый владелец может свободно его изменять.

Для передачи права владения мутируемым объектом можно использовать и другие механизмы публикации, но 
необходимо обеспечивать передачу эстафеты только одному потоку. Лучше всего с этим справляются 
блокирующие очереди. Немного дополнительной работы в этом направлении по требуют атомарный метод 
remove ассоциативного массива ConcurrentMap или метод compareAndSet атомарной ссылки AtomicReference.

### 5.3.3. Двухсторонние очереди и кража работы

Java 6 также предоставляет очереди Deque и BlockingDeque, которые расширяют очереди Queue и 
BlockingQueue. Реализации класса Deque включают ArrayDeque и LinkedBlockingDeque.

Блокирующие очереди поддаются паттерну «производитель-потребитель», а двусторонние очереди — 
родственному паттерну под называнием кража работы (work stealing). Если потребитель исчерпывает 
работу в собственной очереди, он может украсть работу из чужой, что улучшает масштабируемость из-за 
сокращения конфликта: потребитель чаще обращается к собственной очереди, а просмотр чужой очереди 
начинает с хвоста. Таким образом каждый потребитель занят.

## 5.4. Блокирующие и прерываемые методы

Потоки могут блокировать продвижение, если ожидают завершения ввода-вывода, приобретения замка, 
пробуждения ото сна Thread.sleep или результата вычисления в другом потоке. Помещаясь в состояние 
BLOCKED, WAITING или TIMED_WAITING, поток не контролирует задачу, завершения которой ожидает, и 
возвращается в состояние работоспособности RUNNABLE только после возникновения внешнего события.

Методы put и take класса BlockingQueue выдают проверяемое исключение InterruptedException, как и ряд 
других библиотечных методов, таких как Thread.sleep. Данное исключение отличает блокирующие методы, 
которые активно сопротивляются собственному прерыванию.

Вызывая метод, который выдает исключение InterruptedException, ваш метод также становится блокирующим 
и должен уметь откликаться на прерывание. В случае библиотечного кода существует два варианта:

- Распространить исключение InterruptedException. Эта политика предусматривает неотлавливание
  исключения либо его отлавливание и повторную выдачу после выполнения краткой очистки.
- Восстановить прерывание. Когда распространить исключение невозможно (например, код является частью
  Runnable), необходимо перехватить исключение и восстановить статус прерванности, вызвав метод
  interrupt в текущем потоке, чтобы код выше в стеке вызовов видел выполненное прерывание.

Восстановление прерванного статуса

```java
public class TaskRunnable implements Runnable {
    BlockingQueue<Task> queue;
    ...
    public void run() {
        try {
            processTask(queue.take());
        } catch (InterruptedException e) {
            // восстановить статус прерванности
            Thread.currentThread().interrupt();
        }
    }
}
```

## 5.5. Синхронизаторы

Синхронизатор (synchronizer) — это любой объект, координирующий поток управления в остальных потоках, 
основываясь на их состоянии. В качестве синхронизаторов могут выступать блокирующие очереди, 
семафоры, барьеры и защелки. В платформенной библиотеке существует несколько классов синхронизаторов. 
Если они не отвечают вашим потребностям, то вы можете создать свои.

### 5.5.1. Защелки

Защелка (latch) представляет собой синхронизатор, который может задерживать продвижение потоков до 
достижения своего конечного состояния. Он действует как закрытый шлюз, который в определенный момент 
разрешает всем потокам пройти, и навсегда остается открытым. Защелки сдерживают некие действия до 
завершения других важных действий, приведенных ниже:
- Инициализация ресурсов.
- Запуск служб, от которых зависит действие.
- Готовность всех участников

Класс CountDownLatch представляет собой гибкую реализацию защелки. Состояние защелки состоит из 
счетчика, инициализируемого положительным числом ожидаемых событий. Метод countDown уменьшает 
счетчик, сигнализируя о том, что произошло событие, и методы await ожидают до тех пор, пока счетчик 
не достигнет нуля, т. е. все события завершатся.

Использование CountDownLatch для запуска и остановки потоков в тестах с хронометражем

```java
public class TestHarness {
    public long timeTasks(int nThreads, final Runnable task) throws InterruptedException {
        final CountDownLatch startGate = new CountDownLatch(1);
        final CountDownLatch endGate = new CountDownLatch(nThreads);
        for (int i = 0; i < nThreads; i++) {
            Thread t = new Thread() {
                public void run() {
                    try {
                        startGate.await();
                        try {
                            task.run();
                        } finally {
                            endGate.countDown();
                        }
                    } catch (InterruptedException ignored) { }
                }
            };
            t.start();
        }
        long start = System.nanoTime();
        startGate.countDown();
        endGate.await();
        long end = System.nanoTime();
        return end-start;
    }
}
```

### 5.5.2. FutureTask

FutureTask действует как защелка: он реализует Future, описывающий абстрактные вычисления, приносящие 
результат, которые реализуются с помощью интерфейса Callable, эквивалентного Runnable. Они могут 
находиться в состоянии ожидания выполнения, самого выполнения либо завершения (нормального 
завершения, отмены или прерывания). FutureTask, приняв завершенное состояние, остается в нем навсегда.

Использование FutureTask для предварительной загрузки данных, которые потребуются позже

public class Preloader {
    private final FutureTask<ProductInfo> future = new FutureTask<ProductInfo>(
                                                       new Callable<ProductInfo>() {
        public ProductInfo call() throws DataLoadException {
            return loadProductInfo();
        }
    });
    private final Thread thread = new Thread(future);
    public void start() { thread.start(); }
    public ProductInfo get() throws DataLoadException, InterruptedException {
        try {
            return future.get();
        } catch (ExecutionException e) {
            Throwable cause = e.getCause();
            if (cause instanceof DataLoadException) throw (DataLoadException) cause;
            else
                throw launderThrowable(cause);
        }
    }
}

### 5.5.3. Семафоры

Счетные семафоры (сounting semaphores) регулируют число действий, способных обращаться к 
определенному ресурсу или выполнять одну и ту же задачу в одно и то же время. Счетные семафоры можно 
использовать для реализации ресурсных пулов или наложения лимита на коллекцию.

Использование семафора для связывания коллекции

```java
public class BoundedHashSet<T> {
    private final Set<T> set;
    private final Semaphore sem;
    public BoundedHashSet(int bound) {
        this.set = Collections.synchronizedSet(new HashSet<T>());
        sem = new Semaphore(bound);
    }
    public boolean add(T o) throws InterruptedException {
        sem.acquire();
        boolean wasAdded = false;
        try {
            wasAdded = set.add(o);
            return wasAdded;
        }
        finally {
            if (!wasAdded) sem.release();
        }
    }
    public boolean remove(Object o) {
        boolean wasRemoved = set.remove(o);
        if (wasRemoved) sem.release();
        return wasRemoved;
    }
}
```

### 5.5.4. Барьеры

Барьеры (barriers) подобны защелкам в том, что они блокируют группу потоков до наступления какого-то 
события. Но в отличие от защелки барьер заставляет потоки вместе проходить барьерную точку в одно и 
то же время, чтобы продолжить работу. Защелки предназначены для ожидания событий, а барьеры — для 
ожидания других потоков.

Класс CyclicBarrier позволяет фиксированному числу сторон неоднократно назначать встречу в барьерной 
точке. Потоки достигают барьерной точки и вызывают метод await, который  блокирует продвижение, пока 
все потоки не сделают то же самое. Если барьер успешно пройден, все потоки выпускаются, и барьер 
переустанавливается для следующего использования.  Если барьер успешно пройден, то метод await 
возвращает уникальный индекс прибытия каждому потоку.  CyclicBarrier также позволяет передавать 
барьерное действие конструктору, реализуя интерфейс Runnable в одном из подзадачных потоков, после 
прохождения барьера, но до освобождения блокированных потоков.

Координирование вычислений в клеточном автомате с помощью барьера CyclicBarrier

```java
public class CellularAutomata {
    private final Board mainBoard;
    private final CyclicBarrier barrier;
    private final Worker[] workers;
    public CellularAutomata(Board board) {
        this.mainBoard = board;
        int count = Runtime.getRuntime().availableProcessors();
        this.barrier = new CyclicBarrier(count,
            new Runnable() {
                public void run() {
                    mainBoard.commitNewValues();
                }
            });
        this.workers = new Worker[count];
        for (int i = 0; i < count; i++) workers[i] = new Worker(mainBoard.getSubBoard(count, i));
    }
    private class Worker implements Runnable {
        private final Board board;
        public Worker(Board board) { this.board = board; }
        public void run() {
            while (!board.hasConverged()) {
                for (int x = 0; x < board.getMaxX(); x++)
                    for (int y = 0; y < board.getMaxY(); y++)
                        board.setNewValue(x, y, computeValue(x, y));
                try {
                    barrier.await();
                } catch (InterruptedException ex) {
                    return;
                } catch (BrokenBarrierException ex) {
                    return;
                }
            }
        }
    }
    public void start() {
        for (int i = 0; i < workers.length; i++)
            new Thread(workers[i]).start();
        mainBoard.waitForConvergence();
    }
}
```

Еще одной формой барьера является обменник Exchanger — двухсторонний барьер, в котором стороны 
обмениваются данными в барьерной точке.

## 5.6. Создание эффективного масштабируемого кэша результатов

Первоначальный подход к кэшированию с использованием HashMap и синхронизации

```java
public interface Computable<A, V> {
    V compute(A arg) throws InterruptedException;
}
public class ExpensiveFunction
        implements Computable<String, BigInteger> {
    public BigInteger compute(String arg) {
        // после глубокого раздумья...
        return new BigInteger(arg);
    }
}
public class Memoizer1<A, V> implements Computable<A, V> {
    @GuardedBy("this")
    private final Map<A, V> cache = new HashMap<A, V>();
    private final Computable<A, V> c;
    public Memoizer1(Computable<A, V> c) {
        this.c = c;
    }
    public synchronized V compute(A arg) throws InterruptedException {
        V result = cache.get(arg);
        if (result == null) {
            result = c.compute(arg);
            cache.put(arg, result);
        }
        return result;
    }
}
```

![image](https://github.com/Moseshiga/Java_Concurrency_in_practice/assets/46221930/e2fc4ee5-b36f-4c02-bb7a-cf16522f376e)

Как результат получаем слабую конкурентность класса Memoizer1.

Замена HashMap на ConcurrentHashMap

```java
public class Memoizer2<A, V> implements Computable<A, V> {
    private final Map<A, V> cache = new ConcurrentHashMap<A, V>();
    private final Computable<A, V> c;
    public Memoizer2(Computable<A, V> c) { this.c = c; }
    public V compute(A arg) throws InterruptedException {
        V result = cache.get(arg);
        if (result == null) {
            result = c.compute(arg);
            cache.put(arg, result);
        }
        return result;
    }
}
```

![image](https://github.com/Moseshiga/Java_Concurrency_in_practice/assets/46221930/e675f700-ff3b-464f-ab0d-78a0f268ff93)

Два потока вычисляют одно и то же значение при использовании Memoizer2

Запоминающая обертка с использованием FutureTask

```java
public class Memoizer3<A, V> implements Computable<A, V> {
    private final Map<A, Future<V>> cache
            = new ConcurrentHashMap<A, Future<V>>();
    private final Computable<A, V> c;
    public Memoizer3(Computable<A, V> c) { this.c = c; }
    public V compute(final A arg) throws InterruptedException {
        Future<V> f = cache.get(arg);
        if (f == null) {
            Callable<V> eval = new Callable<V>() {
                public V call() throws InterruptedException {
                    return c.compute(arg);
                }
            };
            FutureTask<V> ft = new FutureTask<V>(eval);
            f = ft;
            cache.put(arg, ft);
            ft.run(); // вызов c.compute происходит тут
        }
        try {
            return f.get();
        } catch (ExecutionException e) {
            throw launderThrowable(e.getCause());
        }
    }
}
```

Реализация класса Memoizer3 демонстрирует очень хорошую конкурентность, но остается окно уязвимости 
(оно меньше, чем в Memoizer2), в котором два потока могут вычислить одно и то же значение. Блок if в 
методе compute по-прежнему является неатомарной последовательностью «проверить и затем действовать», 
и два потока могут одновременно вызвать метод compute с одним и тем же значением, увидеть, что кэш не 
содержит желаемого значения, и начать вычисление.

![image](https://github.com/Moseshiga/Java_Concurrency_in_practice/assets/46221930/aef8a05c-464b-4f63-8a7f-a43f1f29449b)

Класс Memoizer3 уязвим, потому что составная операция «добавить, если отсутствует» выполняется на 
резервном ассоциативном массиве, и ее нельзя сделать атомарной с помощью замка. Класс Memoizer 
закрывает окно уязвимости атомарным методом putIfAbsent ассоциативного массива ConcurrentMap.

Memoizer не решает задачу с истечением срока действия кэша, но он может обратиться к подклассу 
FutureTask, который ассоциирует время истечения срока с каждым результатом и периодически проверяет 
кэш на наличие данных с истекшим сроком. (Также Memoizer не решает проблему вытеснения кэша, при 
котором старые записи удаляются для разгрузки памяти.)

Окончательная реализация класса Memoizer

```java
public class Memoizer<A, V> implements Computable<A, V> {
    private final ConcurrentMap<A, Future<V>> cache = new ConcurrentHashMap<A, Future<V>>();
    private final Computable<A, V> c;
    public Memoizer(Computable<A, V> c) {
        this.c = c;
    }
    public V compute(final A arg) throws InterruptedException {
        while (true) {
            Future<V> f = cache.get(arg);
            if (f == null) {
                Callable<V> eval = new Callable<V>() {
                    public V call() throws InterruptedException {
                        return c.compute(arg);
                    }
                };
                FutureTask<V> ft = new FutureTask<V>(eval);
                f = cache.putIfAbsent(arg, ft);
                if (f == null) {
                    f = ft;
                    ft.run();
                }
            }
            try {
                return f.get();
            } catch (CancellationException e) {
                cache.remove(arg, f);
            } catch (ExecutionException e) {
                throw launderThrowable(e.getCause());
            }
        }
    }
}
```

**Итоги**

• Это мутируемое состояние, дурачок.
Все вопросы конкурентности сводятся к координированию доступа к мутируемому состоянию. Чем менее 
мутируемо состояние, тем легче обеспечить потокобезопасность.
• Объявляйте поля финальными, если нет необходимости в том, чтобы они были мутируемыми.
• Немутируемые объекты автоматически являются потокобезопасными.
Немутируемые объекты упрощают конкурентное программирование. Они могут свободно использоваться без 
блокировки или защитного копирования.
• Инкапсуляция позволяет управлять сложностью.
Можно написать потокобезопасную программу, в которой все данные хранятся в глобальных переменных, но 
зачем? Инкапсулирование данных внутри объектов упрощает соблюдение их инвариантов, а инкапсулирование 
синхронизации внутри объектов упрощает соблюдение их политики синхронизации.
• Защищайте каждую мутируемую переменную с помощью замка.
• Защищайте все переменные в инварианте с помощью одинаковых замков.
• Удерживайте замки в течение всего времени составных действий. 
• Программа, которая обращается к мутируемой переменной из многочисленных потоков без синхронизации, 
неисправна.
• Не верьте доводам, что обойдетесь без синхронизации.
• Включайте потокобезопасность в процесс проектирования либо явным образом документируйте то, что 
класс не является потокобезопасным.
• Документируйте политику синхронизации.

**Часть II Структурирование конкурентных приложений**

# Выполнение задач

Большинство конкурентных приложений организованы вокруг выполнения задач (tasks) — абстрактных 
дискретных единиц работы. Разделение работы приложения на задачи упрощает организацию программы, 
облегчает обнаружение и исправление ошибок, предоставляя естественные транзакционные границы, и 
способствует конкурентности, обеспечивая естественную структуру для параллелизации работы.

## 6.1. Выполнение задач в потоках

Первым шагом в организации программы вокруг выполнения задачи является определение разумных границ 
задач (task boundaries). Незави‑ симые друг от друга задачи могут выполняться параллельно при наличии 
достаточных обрабатывающих ресурсов. Для большей гибкости в планировании и распределении нагрузки 
каждая задача должна представлять собой небольшую часть вычислительной емкости приложения.

Серверные приложения должны демонстрировать хорошую пропускную способность, высокую отзывчивость, а 
также плавную деградацию по мере перегрузки.

### 6.1.1. Последовательное выполнение задач

Класс SingleThreadWebServer обрабатывает HTTP-запросы, поступающие на порт 80, последовательно. 

Последовательный веб-сервер

```java
class SingleThreadWebServer {
    public static void main(String[] args) throws IOException {
        ServerSocket socket = new ServerSocket(80);
        while (true) {
            Socket connection = socket.accept();
            handleRequest(connection);
        }
    }
}
```

Простой и правильный класс SingleThreadedWebServer неэффективен в рабочей среде, поскольку 
обрабатывает только один запрос за раз. Пока главный поток попеременно принимает соединения и 
обрабатывает ассоциированный запрос, новые соединения должны ожидать завершения текущего запроса и 
вызова метода accept. К сожалению, handleRequest не может возвращаться мгновенно.

### 6.1.2. Явное создание потоков для задач

Веб-сервер, запускающий новый поток для каждого запроса

```java
class ThreadPerTaskWebServer {
    public static void main(String[] args) throws IOException {
        ServerSocket socket = new ServerSocket(80);
        while (true) {
            final Socket connection = socket.accept();
            Runnable task = new Runnable() {
                public void run() {
                    handleRequest(connection);
                }
            };
            new Thread(task).start();
        }
    }
}
```

- главный цикл может принимать новые подключения до завершения
  предыдущих запросов;
- задачи могут обрабатываться параллельно, что повышает пропускную способность, если имеются
  многочисленные процессоры либо задача нуждается в блокировании;
- возрастает необходимость потокобезопасности кода обработки.

До тех пор пока скорость поступления запросов не превышает емкость сервера для обработки запросов, 
этот подход обеспечивает высокую отзывчивость и пропускную способность.

### 6.1.3. Недостатки создания неограниченных потоков

Вместе с тем подход «поток в расчете на задачу» имеет практические недостатки:

- **Пул потоков фиксированного размера** Создание потока занимает время и требует некоторой
  обрабатывающей деятельности со стороны JVM и ОС, поэтому не приносит пользы при высокой частоте
  запросов

- **Ресурсопотребление** Активные потоки потребляют системные ресурсы, в особенности память. Свободные
  потоки в большом количестве могут связывать часть памяти, оказывая давление на сборщика мусора,
  а избыток потоков, которые конфликтуют за процессоры, может вносить другие стоимости для
  производительности. Если у вас достаточнопотоков, чтобы занять все процессоры, создание большего
  числа потоков нецелесообразно.

- **Стабильность** Существует лимит на число создаваемых потоков, который зависит от многих факторов.
  Достижение лимита приводит к появлению ошибки OutOfMemoryError, после которой восстановление
  рискованно. Структурируйте программу так, чтобы избежать попадания в лимит.

Необходимо установить лимит на число потоков, создаваемых приложением, и обеспечить, чтобы даже при 
достижении этого лимита ресурсы не заканчивались (с помощью тестирования).

## 6.2. Фреймворк Executor

Интерфейс Executor

```java
public interface Executor {
    void execute(Runnable command);
}
```

Интерфейс Executor обеспечивает отделение предоставления задачи от ее выполнения с помощью интерфейса 
Runnable и поддерживает жизненный цикл программы и перехватчиков для добавления функционала сбора 
статистики, управления приложением и мониторинга. 
Использование Executor является одним из самых простых способов реа‑ лизации паттерна «производитель-
потребитель».

### 6.2.1. Пример: веб-сервер с использованием Executor

TaskExecutionWebServer использует одну из стандартных реализаций исполнителя Executor — пул в 100 
потоков фиксированного размера.

Веб-сервер, использующий пул потоков

```java
class TaskExecutionWebServer {
    private static final int NTHREADS = 100;
    private static final Executor exec = Executors.newFixedThreadPool(NTHREADS);
    public static void main(String[] args) throws IOException {
        ServerSocket socket = new ServerSocket(80);
        while (true) {
            final Socket connection = socket.accept();
            Runnable task = new Runnable() {
                public void run() {
                    handleRequest(connection);
                }
            };
            exec.execute(task);
        }
    }
}
```

### 6.2.2. Политики выполнения

Отделение предоставления задачи от ее выполнения позволяет легко специфицировать и впоследствии без 
особых трудностей изменять политику выполнения для выбранного класса задач. Спецификация политики 
выполнения отвечает на вопросы:

- В каком потоке будут выполняться задачи?
- Каков порядок выполнения задач (FIFO, LIFO, приоритетный порядок)?
- Сколько задач может выполняться конкурентно?
- Сколько задач может быть поставлено в очередь?
- Какую задачу удалить из-за перегрузки системы и как уведомить приложение?
- Какие действия предпринимать до и после выполнения задачи?

Код в форме:
*new Thread(runnable).start()*
сигнализирует о возможности его замены на исполнитель Executor.

### 6.2.3. Пулы потоков

Библиотека классов предоставляет гибкую реализацию пула потоков, который можно создать, вызвав один 
из статических фабричных методов в исполнителях Executor: 

- newFixedThreadPool. Пул потоков фиксированного размера создает определенное число потоков по мере
  предоставления задач, а затем старается держать размер пула постоянным.
- newCachedThreadPool. Более гибкий кэшированный пул потоков убирает простаивающие потоки и при
  необходимости добавляет новые, не накладывая лимит на размер пула.
- newSingleThreadExecutor. Исполнитель создает один поток для последовательной обработки задач,
  который при необходимости можно заменить.
- newScheduledThreadPool. Пул потоков фиксированного размера, который поддерживает отложенное и
  периодическое выполнение задач аналогично классу Timer.

Использование исполнителя Executor открывает расширенные возможности по настройке, управлению, 
мониторингу, журналированию, отчетности об ошибках и позволяет вносить другие дополнения, доступные 
благодаря структуре выполнения задач.

### 6.2.4. Жизненный цикл исполнителя Executor

Исполнитель Executor отключается, когда все (не являющиеся демонами) потоки терминированы, после чего 
следует выход JVM

Задачами, предоставленными службе ExecutorService после ее выключения, занимается обработчик 
отклоненного выполнения, который может отклонить задачу или вызвать метод execute для выдачи 
непроверяемого исключения RejectedExecutionException. Как только все задачи завершены, служба 
ExecutorService переходит в терминированное состояние. Обычно сразу за методом shutdown следует метод 
awaitTermination, создающий эффект синхронного выключения службы ExecutorService.

### 6.2.5. Отложенные и периодические задачи

Механизм Timer управляет выполнением отложенных и периодических задач. Его альтернативой является 
исполнитель ScheduledThreadPoolExecutor, который можно создать с помощью его собственного 
конструктора либо фабричного метода newScheduledThreadPool.

Чтобы построить свою службу планирования, воспользуйтесь очередью DelayQueue, предоставляющей 
функциональные возможности планирования в исполнителе ScheduledThreadPoolExecutor. Она управляет 
сбором отложенных объектов Delayed, каждый из которых имеет ассоциированное с ним время задержки: 
очередь DelayQueue позволяет принимать элемент (метод take), только если его задержка истекла. 
Объекты возвращаются из очереди DelayQueue, упорядоченной по времени, ассоциированному с их задержкой.

## 6.3. Поиск эксплуатационно-пригодного параллелизма

### 6.3.1. Пример: последовательный страничный  отрисовщик

Последовательная обработка HTML-документа подразумевает при появлении текстовой разметки ее отрисовку 
в буфере изображений, а при появлении ссылок на изображение — их доставку по сети и отрисовку в 
буфере изображений. Такая обработка требует прикосновения к каждому входному элементу всего один раз, 
но может занять много времени.

Последовательная отрисовка элементов страницы

```java
public class SingleThreadRenderer {
    void renderPage(CharSequence source) {
        renderText(source);
        List<ImageData> imageData = new ArrayList<ImageData>();
        for (ImageInfo imageInfo : scanForImageInfo(source))
            imageData.add(imageInfo.downloadImage());
        for (ImageData data : imageData)
            renderImage(data);
    }
}
```

### 6.3.2. Задачи, приносящие результаты: Callable и Future

Для отложенных задач интерфейс Callable является более подходящей абстракцией: он ожидает, что 
главная точка входа, call, вернет значение, и готов, если потребуется, выдать исключение. (Для того 
чтобы с помощью Callable выразить задачу, не возвращающую значения, следует использовать 
Callable<Void>).

Интерфейс Future предоставляет методы, которые проверяют, была ли задача завершена или отменена, 
извлекают ее результат и при необходимости отменяют ее.

Интерфейсы Callable и Future

```java
public interface Callable<V> {
    V call() throws Exception;
}
public interface Future<V> {
    boolean cancel(boolean mayInterruptIfRunning);
    boolean isCancelled();
    boolean isDone();
    V get() throws InterruptedException, ExecutionException,
            CancellationException;
    V get(long timeout, TimeUnit unit)
            throws InterruptedException, ExecutionException,
            CancellationException, TimeoutException;
}
```

### 6.3.3. Пример: страничный отрисовщик с объектом Future

В качестве первого шага к тому, чтобы сделать страничный отрисовщик более конкурентным, разделим его 
на две подзадачи: отрисовку текста и скачивание изображений. (Поскольку одна задача в значительной 
степени привязана к процессору, а другая — к вводу-выводу, этот подход может привести к улучшениям 
даже в однопроцессорных системах.)

```java
public class FutureRenderer {
    private final ExecutorService executor = ...;
    void renderPage(CharSequence source) {
        final List<ImageInfo> imageInfos = scanForImageInfo(source);
        Callable<List<ImageData>> task =
                new Callable<List<ImageData>>() {
                    public List<ImageData> call() {
                        List<ImageData> result
                                = new ArrayList<ImageData>();
                        for (ImageInfo imageInfo : imageInfos)
                            result.add(imageInfo.downloadImage());
                        return result;
                    }
                };
        Future<List<ImageData>> future = executor.submit(task);
        renderText(source);
        try {
            List<ImageData> imageData = future.get();
            for (ImageData data : imageData)
                renderImage(data);
        } catch (InterruptedException e) {
            // Переподтвердить статус прерванности потока
            Thread.currentThread().interrupt();
            // Нам не нужен результат, поэтому отменить задачу
            future.cancel(true);
        } catch (ExecutionException e) {
            throw launderThrowable(e.getCause());
        }
    }
}
```

Класс FutureRenderer позволяет отрисовывать текст конкурентно со скачиванием данных изображения. 
Когда все изображения скачаны, они отрисовываются на странице. Пользователям нет необходимости ждать, 
когда все изображения будут скачаны; они, скорее, предпочтут видеть изображения по мере их появления.

### 6.3.4. Ограничения параллелизации разнородных задач

Проблема с разделением разнородных задач между многочисленными работниками заключается в том, что 
задачи могут иметь несопоставимые размеры. Если вы разделите задачи A и B между двумя работниками, но 
A будет занимать в десять раз больше времени, чем B, то вы ускорите суммарный процесс только на 9 %. 
Наконец, для того чтобы разделение было оправданным, издержки на координацию должны компенсироваться 
повышением производительности.

Класс FutureRenderer использует две задачи: одну для отрисовки текста и одну для скачивания 
изображений. Если отрисовка текста происходит намного быстрее, чем скачивание изображений, то 
результирующая производительность не будет отличаться от полученной в последовательной версии, но код 
будет намного сложнее. Существует предел количества дополнительной конкурентности, выигранной от 
разделения задачи.

Реальная отдача от разделения рабочей нагрузки программы на задачи достигается при наличии большого 
числа независимых однородных задач, которые могут обрабатываться конкурентно.

### 6.3.5. CompletionService: исполнитель Executor встречается с очередью BlockingQueue

Если у вас есть пакет вычислений для предоставления исполнителю Executor и вы хотите извлекать их 
результаты по мере появления существует оптимальный способ: служба завершения (CompletionService).

Она сочетает в себе функциональность исполнителя Executor и блокирующей очереди BlockingQueue. Вы 
можете предоставлять ей задачи Callable на выполнение и использовать методы take и poll.

Реализация службы ExecutorCompletionService довольно проста. Конструктор создает очередь 
BlockingQueue для хранения завершенных результатов. Класс FutureTask содержит метод done, который 
вызывается по завершении вычислений. Когда задача предоставлена, она обертывается в QueueingFuture, 
подкласс класса FutureTask, который переопределяет метод done, помещая результат в очередь 
BlockingQueue.

```java
private class QueueingFuture<V> extends FutureTask<V> {
    QueueingFuture(Callable<V> c) { super(c); }
    QueueingFuture(Runnable t, V r) { super(t, r); }
    protected void done() {
        completionQueue.add(this);
    }
}
```

### 6.3.6. Пример: страничный отрисовщик со службой CompletionService

Мы можем создать отдельную задачу для скачивания каждого изображения и его выполнения в пуле потоков, 
превратив последовательное скачивание в параллельное: это сократит время скачивания всех изображений. 
А путем доставки результатов из службы CompletionService и отрисовки каждого изображения, как только 
оно будет в наличии, мы дадим пользователю динамичный и отзывчивый пользовательский интерфейс.

Использование службы CompletionService для отрисовки страничных элементов по мере их доступности

```java
public class Renderer {
    private final ExecutorService executor;
    Renderer(ExecutorService executor) { this.executor = executor; }
    void renderPage(CharSequence source) {
        final List<ImageInfo> info = scanForImageInfo(source);
        CompletionService<ImageData> completionService =
                new ExecutorCompletionService<ImageData>(executor);
        for (final ImageInfo imageInfo : info)
            completionService.submit(new Callable<ImageData>() {
                public ImageData call() {
                    return imageInfo.downloadImage();
                }
            });
        renderText(source);
        try {
            for (int t = 0, n = info.size(); t < n; t++) {
                Future<ImageData> f = completionService.take();
                ImageData imageData = f.get();
                renderImage(imageData);
            }
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        } catch (ExecutionException e) {
            throw launderThrowable(e.getCause());
        }
    }
}
```

### 6.3.7. Наложение временных ограничений на задачи

Иногда, если действие не завершается в течение определенного времени, то его результат становится 
невостребованным. Например, веб-приложение может доставлять рекламные сообщения из внешнего сервера, 
но если они там отсутствуют в течение двух секунд, оно выводит рекламное сообщение, принятое по 
умолчанию, чтобы не снижать отзывчивость сайта

Важно, чтобы хронометрированные задачи вычисляли результат, который не будет использоваться. Для 
этого задачи управляются собственным бюджетом времени и прерываются, когда истекает время, либо 
отменяются, когда истекает тайм-аут. Если хронометрированный метод get завершается с исключением 
TimeoutException, то вы можете отменить задачу посредством объекта Future. Если задача написана как 
отменяемая, то она может быть терминирована досрочно, для того чтобы не потреблять излишних ресурсов

Получение рекламы с бюджетом времени

```java
Page renderPageWithAd() throws InterruptedException {
    long endNanos = System.nanoTime() + TIME_BUDGET;
    Future<Ad> f = exec.submit(new FetchAdTask());
    // Отрисовать страницу в ожидании рекламы
    Page page = renderPageBody();
    Ad ad;
    try {
        // Ожидать только на протяжении оставшегося бюджета времени
        long timeLeft = endNanos - System.nanoTime();
        ad = f.get(timeLeft, NANOSECONDS);
    } catch (ExecutionException e) {
        ad = DEFAULT_AD;
    } catch (TimeoutException e) {
        ad = DEFAULT_AD;
        f.cancel(true);
    }
    page.setAd(ad);
    return page;
}
```

### 6.3.8. Пример: портал бронирования поездок

Рассмотрим программу, где пользователь вводит даты и требования, а портал доставляет и выводит 
коммерческие предложения от ряда авиакомпаний, отелей и компаний по прокату автомобилей.

Запрос цен на поездки в рамках бюджета времени

```java
private class QuoteTask implements Callable<TravelQuote> {
    private final TravelCompany company;
    private final TravelInfo travelInfo;
    ...
    public TravelQuote call() throws Exception {
        return company.solicitQuote(travelInfo);
    }
}
public List<TravelQuote> getRankedTravelQuotes(
        TravelInfo travelInfo, Set<TravelCompany> companies,
        Comparator<TravelQuote> ranking, long time, TimeUnit unit)
        throws InterruptedException {
    List<QuoteTask> tasks = new ArrayList<QuoteTask>();
    for (TravelCompany company : companies)
        tasks.add(new QuoteTask(company, travelInfo));
    List<Future<TravelQuote>> futures = exec.invokeAll(tasks, time, unit);
    List<TravelQuote> quotes = new ArrayList<TravelQuote>(tasks.size());
    Iterator<QuoteTask> taskIter = tasks.iterator();
    for (Future<TravelQuote> f : futures) {
        QuoteTask task = taskIter.next();
        try {
            quotes.add(f.get());
        } catch (ExecutionException e) {
            quotes.add(task.getFailureQuote(e.getCause()));
        } catch (CancellationException e) {
            quotes.add(task.getTimeoutQuote(e));
        }
    }
    Collections.sort(quotes, ranking);
    return quotes;
}
```

Тут используется хронометрированная версия метода invokeAll для предоставления многочисленных задач в 
службу ExecutorService и получения результатов. Метод принимает коллекцию задач и возвращает 
коллекцию объектов Future. Две коллекции имеют идентичные структуры; invokeAll добавляет объекты 
Future в возвращаемую коллекцию в порядке, установленном итератором коллекции задач, позволяя 
вызывающему элементу кода связать объект Future с объектом Callable, который он представляет. 
Хронометрированная версия метода invokeAll возвратится после завершения всех задач, прерывания 
вызывающего потока либо истечения тайм-аута. Все задачи, которые не были завершены по истечении тайм-
аута, отменяются.

**Итоги**

Всякий раз, когда вы создаете потоки для выполнения задач, рассмотрите возможность использования
исполнителя Executor.

# 7 Отмена и выключение

Java не предоставляет механизм для безопасной принудительной остановки работы потока, но 
обеспечивает прерывание (interruption) — кооперативный механизм, который позволяет одному потоку 
просить другой поток прекратить действовать.

Кооперативный подход необходим, поскольку мы редко хотим, чтобы задача, поток или служба 
останавливались немедленно, так как это может оставить совместные структуры данных в противоречивом 
состоянии. Мы будем кодировать задачи и службы таким образом, чтобы при запросе они очищали любую 
работу, которая в настоящий момент продолжается, а затем терминировали ее.

В этой главе мы опишем механизмы отмены (cancellation) и прерывания и способы кодирования задач и 
служб, откликающихся на запросы об отмене.

## 7.1. Отмена задачи

Действие доступно для отмены, если внешний код может направить его к остановке до момента его 
нормального завершения в следующих случаях: 

- Отмена по запросу пользователя. Пользователь нажал на кнопку «Отмена» в GUI-приложении или запросил
  отмену через интерфейс управления, такой как JMX (Java Management Extensions). 
- Ограниченное по времени действие. Приложение ведет поиск наилучшего решения в течение определенного
  времени. По истечении срока все задачи в процессе поиска отменяются. 
- События приложения. Приложение ищет лучшее решение, разбивая поиск на несколько задач, работающих в
  разных участках пространства. Когда одна задача находит решение, все остальные задачи отменяются. 
- Ошибки. Если задача веб-обходчика обнаруживает ошибку, другие задачи обхода отменяются, но остается
  запись их текущего состояния для перезапуска. 
- Выключение. При плавном выключении те задачи, которые в настоящий момент продолжаются, могут быть
  доведены до завершения. В случае немедленного выключения задачи, которые в настоящий момент
  выполняются, отменяются.

Класс Prime - Generator, в котором простые числа выводятся до тех пор, пока действие не будет 
отменено, иллюстрирует это техническое решение. Метод cancel устанавливает флажок cancelled, и 
главный цикл опрашивает этот флажок перед поиском следующего простого числа. (Флажок cancelled должен 
быть волатильным.)

```java
@ThreadSafe
public class PrimeGenerator implements Runnable {
    @GuardedBy("this")
    private final List<BigInteger> primes = new ArrayList<BigInteger>();
    private volatile boolean cancelled;
    public void run() {
        BigInteger p = BigInteger.ONE;
        while (!cancelled) {
            p = p.nextProbablePrime();
            synchronized (this) {
                primes.add(p);
            }
        }
    }
    public void cancel() { cancelled = true; }
    public synchronized List<BigInteger> get() {
        return new ArrayList<BigInteger>(primes);
    }
}
```

Задача, задуманная как отменяемая, должна иметь политику отмены, отвечающую на вопросы: как другой 
код может запросить отмену, когда задача проверяет наличие запроса на отмену, какие действия задача 
предпринимает в ответ на запрос об отмене.

### 7.1.1. Прерывание

Если задача, которая использует описанный выше подход, вызовет блокирующий метод, такой как 
BlockingQueue.put, то она может ни разу не проверить флажок отмены и не терминироваться.

В спецификации API или языка прерывание не привязано к какой-либо конкретной семантике отмены, но на 
практике использование прерывания не для отмены является хрупким и трудно сопроводимым механизмом.

Ненадежная отмена, которая может оставить производителей застрявшими в блокирующей операции. Так 
делать не следует

```java
class BrokenPrimeProducer extends Thread {
    private final BlockingQueue<BigInteger> queue;
    private volatile boolean cancelled = false;
    BrokenPrimeProducer(BlockingQueue<BigInteger> queue) {
        this.queue = queue;
    }
    public void run() {
        try {
            BigInteger p = BigInteger.ONE;
            while (!cancelled)
                queue.put(p = p.nextProbablePrime());
        } catch (InterruptedException consumed) { }
    }
    public void cancel() { cancelled = true; }
}
void consumePrimes() throws InterruptedException {
    BlockingQueue<BigInteger> primes = ...;
    BrokenPrimeProducer producer = new BrokenPrimeProducer(primes);
    producer.start();
    try {
        while (needMorePrimes())
            consume(primes.take());
    } finally {
        producer.cancel();
    }
}
```

Каждый поток имеет булев статус прерванности (interrupted status): true или false. Объект Thread 
содержит метод interrupt, прерывающий целевой поток, и метод isInterrupted, возвращающий потоку 
статус прерванности. Очистить статус прерванности можно только статическим методом interrupted.

Блокирующие библиотечные методы, такие как Thread.sleep и Object. wait, быстро отзываются на 
прерывание, очищая статус прерванности и выдавая исключение InterruptedException.

Методы прерывания в классе Thread

```java
public class Thread {
    public void interrupt() { ... }
    public boolean isInterrupted() { ... }
    public static boolean interrupted() { ... }
    ...
}
```

Вызов метода interrupt не обязательно побуждает целевой поток прекратить действия — он только 
доставляет сообщение о том, что прерывание было запрошено.

Прерывание обычно является наиболее разумным способом реализации отмены.

Использование прерывания для отмены

```java
class PrimeProducer extends Thread {
    private final BlockingQueue<BigInteger> queue;
    PrimeProducer(BlockingQueue<BigInteger> queue) {
        this.queue = queue;
    }
    public void run() {
        try {
            BigInteger p = BigInteger.ONE;
            while (!Thread.currentThread().isInterrupted())
                queue.put(p = p.nextProbablePrime());
        } catch (InterruptedException consumed) {
            /* Разрешить потоку выйти */
        }
    }
    public void cancel() { interrupt(); }
}
```

### 7.1.2. Политики прерывания

Задачи не выполняются в потоках, которыми они владеют, — они заимствуют потоки, принадлежащие службе, 
такой как пул потоков. Код, который не является владельцем потока (любой код вне реализации пула), 
должен следить за сохранением статуса прерванности, чтобы владеющий код мог предпринять по нему какие-
либо действия.

Вот почему большинство блокирующих библиотечных методов в ответ на прерывание выдают исключение 
InterruptedException. Они не выполняются в потоке, которым владеют, а сообщают о находке вызывающему 
элементу кода.

Если задача не может распространить исключение InterruptedException на вызывающий ее элемент кода, то 
она должна восстановить статус прерванности после отлова исключения InterruptedException:
*Thread.currentThread().interrupt();*

Не прерывайте поток, если не знаете, как он интерпретирует прерывание.

### 7.1.3. Отклик на прерывание

Существуют две практические стратегии для обработки исключения InterruptedException:
- распространение исключения (возможно, после очистки, специфичной для задачи), после которого метод
  станет прерываемым и блокирующим;
- восстановление статуса прерванности, чтобы код выше в стеке вызовов мог с ним работать.

Распространение исключения InterruptedException сравнимо по простоте с его добавлением в спецификатор 
throws.

Распространение исключения InterruptedException на вызывающие элементы кода

```java
BlockingQueue<Task> queue;
...
public Task getNextTask() throws InterruptedException {
    return queue.take();
}
```

Если вы не хотите или не можете распространить исключение InterruptedException (возможно, потому, что 
ваша задача определяется интерфейсом Runnable), то сохраните запрос на прерывание через 
восстановление статуса прерванности путем повторного вызова метода interrupt. Не следует проглатывать 
исключение, если ваш код не реализует политику прерывания для потока. Класс PrimeProducer 
проглатывает прерывание, но лишь потому, что поток вот-вот терминируется и в стеке вызовов выше нет 
кода, который должен знать о прерывании.

Проглатывание запроса на прерывание разрешено только коду, реализующему политику прерывания потока.

Неотменяемая задача, восстанавливающая прерывание перед выходом

```java
public Task getNextTask(BlockingQueue<Task> queue) {
    boolean interrupted = false;
    try {
        while (true) {
            try {
                return queue.take();
            } catch (InterruptedException e) {
                interrupted = true;
                // проскочить и попытаться снова
            }
        }
    } finally {
        if (interrupted)
            Thread.currentThread().interrupt();
    }
}
```

Когда рабочий поток, принадлежащий исполнителю ThreadPoolExecutor, обнаруживает прерывание, он 
проверяет, выключается ли пул в данный момент. Если это так, то он выполняет очистку пула перед его 
терминированием. В противном случае он может создать новый поток для восстановления пула до нужного 
размера

### 7.1.4. Пример: хронометрированный прогон

Ниже объект Runnable запускает задачу в вызывающем потоке и планирует вторую задачу, которая отменит 
первую после заданного интервала времени. Данный пример нарушает правило: прежде чем прерывать поток, 
узнать его политику прерывания. Метод timedRun вызывается из произвольного потока, и если первая 
задача завершится до истечения тайм-аута, то задача отмены может начать действовать после возвращения 
метода к вызвавшему его элементу кода. Чтобы устранить риск нежелательного результата, нужно 
использовать объект ScheduledFuture, возвращаемый методом schedule, чтобы отменить задачу отмены.

Планирование прерывания на заимствованном потоке. Так делать не следует

```java
private static final ScheduledExecutorService cancelExec = ...;
public static void timedRun(Runnable r, long timeout, TimeUnit unit) {
    final Thread taskThread = Thread.currentThread();
    cancelExec.schedule(new Runnable() {
        public void run() { taskThread.interrupt(); }
    }, timeout, unit);
    r.run();
}
```

Прерывание задачи в выделенном потоке

```java
public static void timedRun(final Runnable r, long timeout, TimeUnit unit)
        throws InterruptedException {
    class RethrowableTask implements Runnable {
        private volatile Throwable t;
        public void run() {
            try { r.run(); }
            catch (Throwable t) { this.t = t; }
        }
        void rethrow() {
            if (t != null)
                throw launderThrowable(t);
        }
    }
    RethrowableTask task = new RethrowableTask();
    final Thread taskThread = new Thread(task);
    taskThread.start();
    cancelExec.schedule(new Runnable() {
        public void run() { taskThread.interrupt(); }
    }, timeout, unit);
    taskThread.join(unit.toMillis(timeout));
    task.rethrow();
}
```

После запуска задачного потока метод timedRun выполняет хронометрированный метод присоединения join с 
только что созданным потоком. После своего возвращения метод join проверяет, выдала ли задача 
исключение, и если да, то повторно выдает его в потоке, вызывающем метод timedRun. Сохраненный объект 
Throwable используется двумя потоками, и поэтому объявляется волатильным с целью его безопасной 
публикации из задачного потока в поток метода timedRun. Мы устранили проблемы, описанные в предыдущих 
примерах, но пока не знаем, возвращено ли управление и истек ли тайм-аут метода join.

thread join: https://www.baeldung.com/java-thread-join

### 7.1.5. Отмена с помощью Future

Объект Future содержит метод cancel, который принимает булев аргумент mayInterruptIfRunning и 
возвращает значение, указывающее на успешность или неуспешность попытки отмены. (Оно сообщает о 
доставке прерывания, а не об обнаружении задачи или каких-то действиях по прерыванию.) Аргумент, равный 
true, сообщает о прерывании потока, в котором работает задача. Когда можно вызывать метод cancel с 
аргументом true? Можно безопасно устанавливать аргумент mayInterruptIfRunning при отмене задач, 
работающих в стандартном исполнителе Executor. Не следует прерывать принадлежащий пулу поток 
непосредственно при попытке отменить задачу, так как вы не будете знать, какая задача работает во время 
доставки запроса на прерывание: делайте это только через объект Future задачи. Кодируя задачи так, 
чтобы они рассматривали прерывание как запрос на отмену, вы обеспечиваете возможность их отмены через 
Future.

Отмена задачи с помощью Future

```java
public static void timedRun(Runnable r, long timeout, TimeUnit unit) throws InterruptedException {
    Future<?> task = taskExec.submit(r);
    try {
        task.get(timeout, unit);
    } catch (TimeoutException e) {
        // задача будет отменена ниже
    } catch (ExecutionException e) {
        // исключение выдано в задаче; выдать повторно
        throw launderThrowable(e.getCause());
    } finally {
        // Безвредно, если задача уже завершена
        task.cancel(true); // прервать, если работает
    }
}
```

Когда метод Future.get выдает исключение InterruptedException (или TimeoutException), и вы знаете, что 
результат больше не нужен, то отмените задачу с помощью метода Future.cancel.

### 7.1.6. Работа с непрерываемым блокированием

Прерывание потока, заблокированного во время выполнения синхронного сокетного ввода-вывода или ожидания 
приобретения внутреннего замка, не состоится (будет только установлен статус прерванности потока). 
Чтобы убедить поток, блокированный в непрерываемом действии, остановиться с помощью средств, подобных 
прерыванию, нужно понимать механизм его блокирования.

- Синхронный сокетный ввод‑вывод в java.io. Распространенной формой блокирующего ввода-вывода в
  серверных приложениях является чтение из сокета или запись в сокет. К сожалению, методы чтения и
  записи в InputStream и OutputStream не отзываются на прерывание, но закрытие базового сокета
  побуждает любые потоки, блокированные в методах read или write, выдавать исключение SocketException. 
- Синхронный ввод‑вывод в java.nio. Прерывание потока, ожидающего на канале InterruptibleChannel,
  побуждает все потоки, блокированные на этом канале, выдавать исключение ClosedByInterruptException и
  закрывать канал. Закрытие канала InterruptibleChannel побуждает потоки, блокированные на канальных
  операциях, выдавать исключение AsynchronousCloseException. 
- Асинхронный ввод‑вывод с помощью Selector. Если поток заблокирован в методе Selector.select (в
  ava.nio.channels), то метод wakeup побуждает его возвращаться досрочно с исключением
  ClosedSelectorException. 
- Приобретение замка. Нельзя остановить поток, заблокированный во время ожидания внутреннего замка. Но
  можно помочь ему приобрести замок и продвинуться. А явные замковые классы Lock предлагают метод
  lockInterruptibly, который позволяет ожидать замок и при этом отзываться на прерывания (см. главу 13).

Сокрытие нестандартной отмены в потоке Thread путем переопределения метода interrupt

```java
public class ReaderThread extends Thread {
    private final Socket socket;
    private final InputStream in;
    public ReaderThread(Socket socket) throws IOException {
        this.socket = socket;
        this.in = socket.getInputStream();
    }
    public void interrupt() {
        try {
            socket.close();
        }
        catch (IOException ignored) { }
        finally {
            super.interrupt();
        }
    }
    public void run() {
        try {
            byte[] buf = new byte[BUFSZ];
            while (true) {
                int count = in.read(buf);
                if (count < 0)
                    break;
                else if (count > 0)
                    processBuffer(buf, count);
            }
        } catch (IOException e) { /* Позволяет выход потока */ }
    }
}
```

## 7.2. Остановка поточной службы

Приложения обычно создают службы, которые владеют потоками, такие как пулы потоков, и время 
существования этих служб обычно превышает время существования метода, который их создает. Если 
приложение планируется выключить плавно, то потоки, находящиеся во владении этих служб, должны быть 
терминированы: их нужно убедить выключиться самостоятельно.

Инкапсуляция нестандартной отмены в задаче с помощью метода newTaskFor

```java
public interface CancellableTask<T> extends Callable<T> {
    void cancel();
    RunnableFuture<T> newTask();
}
@ThreadSafe
public class CancellingExecutor extends ThreadPoolExecutor {
 ...
    protected<T> RunnableFuture<T> newTaskFor(Callable<T> callable) {
        if (callable instanceof CancellableTask)
            return ((CancellableTask<T>) callable).newTask();
        else
            return super.newTaskFor(callable);
    }
}
public abstract class SocketUsingTask<T> implements CancellableTask<T> {
    @GuardedBy("this") private Socket socket;
    protected synchronized void setSocket(Socket s) { socket = s; }
    public synchronized void cancel() {
        try {

            if (socket != null)
                socket.close();
        } catch (IOException ignored) { }
    }
    public RunnableFuture<T> newTask() {
        return new FutureTask<T>(this) {
            public boolean cancel(boolean mayInterruptIfRunning) {
                try {
                    SocketUsingTask.this.cancel();
                } finally {
                    return super.cancel(mayInterruptIfRunning);
                }
            }
        };
    }
}
```

Приложение может владеть службой, а служба — рабочими потоками, но приложение не владеет рабочими 
потоками и не должно пытаться останавливать их напрямую. Вместо этого служба должна предоставлять 
методы жизненного цикла для самовыключения, которые также выключат принадлежащие ей потоки. Например, 
служба ExecutorService предоставляет методы shutdown и shutdownNow

Предоставляйте методы жизненного цикла, если владеющая потоком служба должна жить дольше метода, 
который ее создал.

### 7.2.1. Пример: служба журналирования

Служба журналирования «производитель-потребитель» без поддержки выключения

```java
public class LogWriter {
    private final BlockingQueue<String> queue;
    private final LoggerThread logger;
    public LogWriter(Writer writer) {
        this.queue = new LinkedBlockingQueue<String>(CAPACITY);
        this.logger = new LoggerThread(writer);
    }
    public void start() { logger.start(); }
    public void log(String msg) throws InterruptedException {
        queue.put(msg);
    }
    private class LoggerThread extends Thread {
        private final PrintWriter writer;
        ...
        public void run() {
            try {
                while (true)
                    writer.println(queue.take());
            } catch(InterruptedException ignored) {
            } finally {
                writer.close();
            }
        }
    }
}
```

Помните, что внезапное выключение выбрасывает журнальные сообщения, ожидающие запись, а 
заблокированные в методе log потоки никогда не будут разблокированы. Отмена в шаблоне подразумевает 
отмену как производителей, так и потребителей, но первых отменить сложнее, так как они не являются 
выделенными потоками.

Добавление надежной отмены в LogWriter

```java
public class LogService {
    private final BlockingQueue<String> queue;
    private final LoggerThread loggerThread;
    private final PrintWriter writer;
    @GuardedBy("this") private boolean isShutdown;
    @GuardedBy("this") private int reservations;
    public void start() { loggerThread.start(); }
    public void stop() {
        synchronized (this) { isShutdown = true; }
        loggerThread.interrupt();
    }
    public void log(String msg) throws InterruptedException {
        synchronized (this) {
            if (isShutdown)
                throw new IllegalStateException(...);
            ++reservations;
        }
        queue.put(msg);
    }
    private class LoggerThread extends Thread {
        public void run() {
            try {
                while (true) {
                    try {
                        synchronized (this) {
                            if (isShutdown && reservations == 0)
                                break;
                        }
                        String msg = queue.take();
                        synchronized (this) { --reservations; }
                        writer.println(msg);
                    } catch (InterruptedException e) { /* повторная попытка */ }
                }
            } finally {
                writer.close();
            }
        }
    }
}
```

Наличие замка заставит метод put блокировать продвижение, поэтому мы будем «резервировать» право 
отправлять сообщение с помощью условного приращения счетчика, атомарно проверяя выключение

### 7.2.2. Выключение службы ExecutorService

Служба журналирования, использующая ExecutorService

```java
public class LogService {
    private final ExecutorService exec = newSingleThreadExecutor();
    ...
    public void start() { }
    public void stop() throws InterruptedException {
        try {
            exec.shutdown();
            exec.awaitTermination(TIMEOUT, UNIT);
        } finally {
            writer.close();
        }
    }
    public void log(String msg) {
        try {
            exec.execute(new WriteTask(msg));
        } catch (RejectedExecutionException ignored) { }
    }
}
```

### 7.2.3. Ядовитые таблетки

Еще один способ убедить службу «производитель-потребитель» выключиться представлен ядовитой 
таблеткой (poison pill) — узнаваемым объектом очереди, получатель которого останавливается. При 
FIFO ядовитая таблетка заставляет потребителей закончить начатое, так как производители не смогут 
предоставлять работу после ее помещения в очередь.

Ядовитые таблетки надежно работают с известным числом производителей и потребителей и 
неограниченными очередями. В службе IndexingService можно увеличить число производителей и 
потребителей, размещая достаточное число таблеток.

Выключение с ядовитой таблеткой

```java
public class IndexingService {
    private static final File POISON = new File("");
    private final IndexerThread consumer = new IndexerThread();
    private final CrawlerThread producer = new CrawlerThread();
    private final BlockingQueue<File> queue;
    private final FileFilter fileFilter;
    private final File root;
    public class CrawlerThread extends Thread {
        public void run() {
            try {
                crawl(root);
            } catch (InterruptedException e) { /* проскочить */ }
            finally {
                while (true) {
                    try {
                        queue.put(POISON);
                        break;
                    } catch (InterruptedException e1) { /* попытаться снова */ }
                }
            }
        }
        private void crawl(File root) throws InterruptedException {
 ...
        }
    }
    public class IndexerThread extends Thread {
        public void run() {
            try {
                while (true) {
                    File file = queue.take();
                    if (file == POISON)
                        break;
                    else
                        indexFile(file);
                }
            } catch (InterruptedException consumed) { }
        }
    }
    public void start() {
        producer.start();
        consumer.start();
    }
    public void stop() { producer.interrupt(); }
    public void awaitTermination() throws InterruptedException {
        consumer.join();
    }
}
```

### 7.2.4. Пример: служба однократного выполнения

Использование приватного исполнителя Executor, время жизни которого ограничено вызовом метода

```java
boolean checkMail(Set<String> hosts, long timeout, TimeUnit unit)
            throws InterruptedException {
        ExecutorService exec = Executors.newCachedThreadPool();
        final AtomicBoolean hasNewMail = new AtomicBoolean(false);
        try {
            for (final String host : hosts)
                exec.execute(new Runnable() {
                    public void run() {
                        if (checkMail(host))
                            hasNewMail.set(true);
                    }
                });
        } finally {
            exec.shutdown();
            exec.awaitTermination(timeout, unit);
        }
        return hasNewMail.get();
}
```

### 7.2.5. Ограничения метода shutdownNow



Служба ExecutorService, отслеживающая отмененные задачи после выключения

Нет способа узнать о состоянии задач, находившихся в процессе работы во время выключения, если сами 
задачи не занимаются установкой своего рода контрольных точек. Для того чтобы узнать, какие задачи 
не были завершены, вам нужно знать, не только какие задачи не были запущены, но и какие задачи 
находились в процессе работы, когда исполнитель быть выключен. 

Класс TrackingExecutor предоставляет решение для нахождения задач, выполняемых во время выключения. 
Инкапсулируя службу ExecutorService и запоминая методом execute (или submit) задачи, отмененные 
после выключения, исполнитель TrackingExecutor идентифицирует, какие задачи были запущены, но не 
завершались корректно. После завершения работы исполнителя метод getCancelledTasks возвращает 
список отмененных задач. Задачи должны сохранять статус прерванности потока при возвращении

```java
public class TrackingExecutor extends AbstractExecutorService {
    private final ExecutorService exec;
    private final Set<Runnable> tasksCancelledAtShutdown =
            Collections.synchronizedSet(new HashSet<Runnable>());
    ...
    public List<Runnable> getCancelledTasks() {
        if (!exec.isTerminated())
            throw new IllegalStateException(...);
        return new ArrayList<Runnable>(tasksCancelledAtShutdown);
    }
    public void execute(final Runnable runnable) {
        exec.execute(new Runnable() {
            public void run() {
                try {
                    runnable.run();
                } finally {
                    if (isShutdown()
                            && Thread.currentThread().isInterrupted())
                        tasksCancelledAtShutdown.add(runnable);
                }
            }
        });
    }
    // делегировать другие методы службы ExecutorService исполнителю
}
```

Исполнитель TrackingExecutor содержит состояние гонки, которое допускает идентификацию завешенных 
задач как отмененных. Пул потоков может быть выключен между моментом выполнения последней 
инструкции задачи и моментом записи завершения задачи. Задачи обходчика идемпотентны (их двукратное 
выполнение имеет тот же эффект, что и однократное). В других случаях будьте готовы к работе с 
ложными утверждениями.

Использование TrackingExecutorService для сохранения незаконченных задач для последующего выполнения

```java
public abstract class WebCrawler {
    private volatile TrackingExecutor exec;
    @GuardedBy("this")
    private final Set<URL> urlsToCrawl = new HashSet<URL>();
    ...
    public synchronized void start() {
        exec = new TrackingExecutor(
                Executors.newCachedThreadPool());
        for (URL url : urlsToCrawl) submitCrawlTask(url);
        urlsToCrawl.clear();
    }
    public synchronized void stop() throws InterruptedException {
        try {
            saveUncrawled(exec.shutdownNow());
            if (exec.awaitTermination(TIMEOUT, UNIT))
                saveUncrawled(exec.getCancelledTasks());
        } finally {
            exec = null;
        }
    }

    protected abstract List<URL> processPage(URL url);
    private void saveUncrawled(List<Runnable> uncrawled) {
        for (Runnable task : uncrawled)
            urlsToCrawl.add(((CrawlTask) task).getPage());
    }
    private void submitCrawlTask(URL u) {
        exec.execute(new CrawlTask(u));
    }
    private class CrawlTask implements Runnable {
        private final URL url;  
        ...
        public void run() {
            for (URL link : processPage(url)) {
                if (Thread.currentThread().isInterrupted())
                    return;
                submitCrawlTask(link);
            }
        }
        public URL getPage() { return url; }
    }
}
```

## 7.3. Обработка аномальной терминации потоков

Ниже показан способ создания рабочего потока в пуле. Если задача создает непроверяемое исключение, то 
она дает потоку умереть, но не раньше, чем уведомит структуру об этом событии. Затем структура может 
заменить поток новым при необходимости. Если вы пишете класс рабочего потока, который выполняет 
предоставленные задачи, или вызываете ненадежный внешний код (например, динамически загружаемые 
подключаемые модули), используйте один из этих подходов, для того чтобы не дать плохо написанной задаче 
или подключаемому модулю уничтожить поток, которому случится его вызвать.

Типичная структура рабочего потока пула потоков

```java
public void run() {
    Throwable thrown = null;
    try {
        while (!isInterrupted())
            runTask(getTaskFromWorkQueue());
    } catch (Throwable e) {
        thrown = e;
    } finally {
        threadExited(this, thrown);
    }
}
```

### 7.3.1. Обработчики неотловленных исключений

Действия обработчика в отношении неотловленных исключений определяются заранее. Например показана 
запись сообщения об ошибке и стековой трассировке в журнал приложения. Также обработчики могут 
выполнять более прямые действия: перезапустить поток, выключить приложение или пролистать оператор.

Интерфейс UncaughtExceptionHandler

```java
public interface UncaughtExceptionHandler {
    void uncaughtException(Thread t, Throwable e);
}
```

```java
public class UEHLogger implements Thread.UncaughtExceptionHandler {
    public void uncaughtException(Thread t, Throwable e) {
        Logger logger = Logger.getAnonymousLogger();
        logger.log(Level.SEVERE, "Поток терминирован с исключением: " + t.getName(), e);
    }
}
```
Для обработки длительных задач всегда используйте обработчики неотловленных исключений для всех 
потоков, которые могут регистрировать исключение в журнале.

## 7.4. Выключение JVM

JVM может выключаться упорядоченно или внезапно. Упорядоченное выключение инициируется, когда 
терминируется последний не являющийся демоном поток, с помощью вызова System.exit или других средств 
(например, отправки SIGINT или нажатия Ctrl-C). Хотя этот способ выключения JVM является стандартным и 
предпочтительным, машина также может быть выключена внезапно путем вызова метода Runtime.halt или 
отправки SIGKILL.

### 7.4.1. Хуки

В упорядоченном выключении JVM-машина сначала запускает хуки (shutdown hooks) — незапущенные потоки, 
которые зарегистрированы с помощью метода Runtime.addShutdownHook. JVM не дает гарантий относительно 
порядка их запуска. Хуки должны быть потокобезопасными — использовать синхронизацию при доступе к 
совместным данным, избегать взаимной блокировки, не делать допущений о состоянии приложения и выходить 
быстро, так как их работа задерживает терминацию JVM.

Хуки можно использовать для очистки служб или приложений, например для удаления временных файлов или 
очистки ресурсов, которые не удаляются операционной системой автоматически

```java
public void start() {
    Runtime.getRuntime().addShutdownHook(new Thread() {
        public void run() {
            try { LogService.this.stop(); }
            catch (InterruptedException ignored) {}
        }
    });
}
```

### 7.4.2. Потоки-демоны

Поток-демон (daemon thread) является вспомогательным потоком, который не мешает выключению JVM.

Новый поток наследует демон-статус создавшего его потока, поэтому потоки, созданные главным потоком, 
являются обычными. Обычные потоки и демоны отличаются только последствиями своего выхода. Когда поток 
выходит, JVM выполняет инвентаризацию запущенных потоков. Если она фиксирует, что остались только 
демоны, она инициирует упорядоченное выключение. Когда JVM останавливается, все оставшиеся потоки-
демоны покидаются — блоки finally не выполняются, стеки не разматываются, — JVM просто выходит

Потоки-демоны не подходят для управления жизненным циклом служб внутри приложения.

### 7.4.3. Финализаторы

Избегайте финализаторов

**Итоги**

Вопросы конца жизненного цикла задач, потоков, служб и приложений могут усложнить их проектирование и 
реализацию. Язык Java не предоставляет упреждающий механизм для отмены действий или терминации потоков. 
Вместо этого он предоставляет кооперативный механизм прерывания, который может быть использован для 
облегчения отмены, но конструирование протоколов отмены и их непротиворечивое применение будут зависеть 
от вас. Использование FutureTask и структуры Executor упрощает построение отменяемых задач и служб.

# 8 Применение пулов потоков

В этой главе мы опишем дополнительные параметры пула потоков и исполнителя Executor, а также сбои при 
использовании структуры выполнения задач.

## 8.1 Неявные стыковки между задачами и политиками выполнения

Cуществуют типы задач, совместимые только с определенными политиками выполнения:

- **Зависимые задачи.** Наиболее благополучные задачи не зависимы от присутствия других задач. При их
  выполнении в пуле вы можете свободно варьировать размер и конфигурацию пула (пострадает только
  производительность). Предоставляя в пул потоков задачи, зависящие от других задач, вы неявно создаете
  ограничения в политике выполнения, которыми необходимо управлять, чтобы избежать проблем
  жизнеспособности
- **Задачи, которые задействуют ограничение одним потоком.** Задачи, созданные для работы в одном потоке,
  требуют, чтобы их исполнитель был однопоточным
- **Задачи, чувствительные ко времени отклика.** Предоставление длительной задачи однопоточному
  исполнителю либо нескольких длительных задач — пулу с малым числом потоков может ухудшить отзывчивость
  службы, управляемой этим исполнителем.
- **Задачи, которые используют класс ThreadLocal.** Класс ThreadLocal позволяет каждому потоку иметь свою
  версию переменной. Его разумно использовать, если локальное для потока значение имеет жизненный цикл,
  ограниченный задачей. ThreadLocal не должен использоваться в потоках пула для обмена значениями между
  задачами.

Документируйте требования задач к политике выполнения.

### 8.1.1. Взаимная блокировка с ресурсным голоданием

Если в пуле выполняются задачи, зависящие от других задач, то они могут быть заперты взаимной 
блокировкой. В однопоточном исполнителе задача, которая предоставляет тому же исполнителю еще одну задачу 
и ожидает ее результат, всегда будет запираться взаимной блокировкой. Вторая задача просидит в рабочей 
очереди, до тех пор пока не завершится первая задача, которая ожидает результат второй задачи. То же 
самое может произойти в больших пулах, если все потоки выполняют задачи, заблокированные в ожидании 
других задач в рабочей очереди. Взаимная блокировка с ресурсным голоданием (thread starvation deadlock) 
может возникать всякий раз, когда задача пула инициирует неограниченное блокирующее ожидание ресурса или 
условия, которое может совершиться только после действия другой задачи пула

Всякий раз, когда вы предоставляете исполнителю Executor зависимые задачи, документируйте в коде или 
конфигурационном файле для Executor любые лимиты на размер пула или конфигурацию.

### 8.1.2. Длительные задачи

Если размер пула слишком мал по сравнению с ожидаемым числом длительных задач, то пострадает 
отзывчивость. Чтобы смягчить негативные последствия длительных задач, можно использовать 
хронометрированные ожидания ресурсов вместо неограниченных. Большинство блокирующих методов в структурных 
библиотеках поставляются в виде нехронометрированных и хронометрированных версий, таких как Thread.join, 
BlockingQueue.put, CountDownLatch.await и Selector.select. Если время ожидания истекло, вы можете 
пометить задачу как безуспешную и прервать ее или поставить ее в очередь заново, чтобы выполнить позже. 
Этим гарантируется, что каждая задача продвигается в направлении успешного или безуспешного завершения, 
освобождая потоки для задач, которые могут завершиться быстрее. Если пул потоков заполнен 
заблокированными задачами, это может означать, что он слишком мал.

## 8.2. Определение размера пула потоков

Чтобы правильно определить размер пула потоков, нужно понимать вычислительную среду, ресурсный бюджет и 
характер задач. Если у вас имеются разные категории задач с очень разными формами поведения, рассмотрите 
возможность использования нескольких пулов, каждый из которых можно отрегулировать в соответствии с его 
рабочей нагрузкой.

Для вычислительно-емких задач Ncpu-процессорная система обычно достигает оптимальной работы с пулом Ncpu 
+ 1. (Даже вычислительно-емкие потоки периодически делают страничный отказ или берут паузу по какойлибо
причине, поэтому «лишний» работоспособный поток защищает от недоиспользования процессорных циклов.) Для
задач, которые включают операции ввода-вывода или другие блокирующие операции, требуется больший пул.
Чтобы правильно определить размер пула, вы должны оценить отношение времени ожидания ко времени
вычисления ваших задач; эта оценочная величина необязательно должна быть точной и может быть получена с
помощью профилирования или контрольных измерений.


![image](https://github.com/Moseshiga/Java_Concurrency_in_practice/assets/46221930/4e3d093b-72a8-4b90-a749-1ba9089ce559)


## 8.3. Конфигурирование класса ThreadPoolExecutor

Класс ThreadPoolExecutor предоставляет базовую реализацию для исполнителей, возвращаемых фабриками 
newCachedThreadPool, newFixedThreadPool и newScheduledThreadExecutor в исполнителях Executor. Исполнитель 
ThreadPoolExecutor представляет собой гибкую, надежную реализацию пула, которая позволяет выполнять 
различные настройки. Если принятая по умолчанию политика выполнения не соответствует вашим потребностям, 
то вы можете создать экземпляр класса ThreadPoolExecutor с помощью его конструктора и настроить его по 
своему усмотрению: обратиться к исходному коду исполнителей Executor и использовать в качестве отправной 
точки политики выполнения для стандартных конфигураций.

### 8.3.1. Создание и удаление потоков

Ядерный размер пула, максимальный размер пула и время поддержания потока в активном состоянии управляют 
созданием и удалением потоков. Ядерный размер — это целевой размер: реализация пытается поддерживать пул 
в этом размере, даже если нет задач для выполнения, и не будет создавать новые потоки, количеством 
превышающие это число, если рабочая очередь не заполнена. Максимальный размер пула — это верхняя граница 
числа потоков пула, которые могут быть активны одновременно. Поток, который простаивал дольше периода 
поддержания потока в активном состоянии, будет терминирован, если текущий размер пула превысит ядерный 
размер.

```java
public ThreadPoolExecutor(int corePoolSize,
    int maximumPoolSize,
    long keepAliveTime,
    TimeUnit unit,
    BlockingQueue<Runnable> workQueue,
    ThreadFactory threadFactory,
    RejectedExecutionHandler handler) { ... }
```

Регулируя ядерный размер пула и время поддержания потоков в активном состоянии, вы можете поощрять пул к 
высвобождению ресурсов, используемых другими простаивающими потоками, что сделает их доступными для 
полезной работы. (Убирая простаивающие потоки, вы вызываете дополнительную задержку из-за создания 
потока, отложенного до момента увеличения спроса на потоки.)

### 8.3.2. Управление задачами очереди

Исполнитель ThreadPoolExecutor позволяет предоставить очередь BlockingQueue для хранения задач, 
ожидающих выполнения. Существует три основных подхода к организации очередности задач: неограниченная 
очередь, ограниченная очередь и синхронная эстафетная передача. Выбор очереди взаимодействует с другими 
параметрами конфигурации, такими как размер пула.

По умолчанию для newFixedThreadPool и newSingleThreadExecutor используется неограниченная очередь 
LinkedBlockingQueue. Задачи помещаются в очередь, если все рабочие потоки заняты, но очередь может расти 
неограниченно, если задачи продолжают поступать быстрее, чем они могут быть выполнены.

Более стабильной стратегией управления ресурсами является использование ограниченной очереди, такой как 
ArrayBlockingQueue, LinkedBlockingQueue или PriorityBlockingQueue. Она помогает предотвратить исчерпание 
ресурсов, но ставит вопрос о том, что делать с новыми задачами, когда очередь заполнена. Размер 
ограниченной рабочей очереди и размер пула должны соответствовать друг другу

Очередь SynchronousQueue является механизмом управления эстафетной передачей между потоками. Элемент 
помещается в SynchronousQueue с помощью ожидающего его потока. Если ни один поток не ожидает, но текущий 
размер пула меньше максимума, то исполнитель ThreadPoolExecutor создает новый поток либо задача 
отклоняется согласно политике насыщения. Благодаря прямой эстафетной передаче задача может быть передана 
непосредственно выполняющему потоку, минуя очередь. SynchronousQueue полезна, если пул неограничен или 
допустимо отклонение избыточных задач. Фабрика newCachedThreadPool использует этот тип очереди.

Фабрика newCachedThreadPool является хорошим выбором для исполнителя Executor, так как обеспечивает 
более высокую производительность очереди, чем фиксированный пул потоков1 , который, в свою очередь, 
уместен при ограниченном числе конкурентных задач.

### 8.3.3. Политика насыщения

Когда ограниченная рабочая очередь заполнена, в игру вступает политика насыщения. Для исполнителя 
ThreadPoolExecutor она может быть изменена путем вызова обработчика setRejectedExecutionHandler. 
(Политика насыщения также используется, когда задача передается исполнителю Executor, который был 
выключен.) Есть несколько реализаций обработчика RejectedExecutionHandler, поддерживающих разные 
политики насыщения: AbortPolicy, CallerRunsPolicy, DiscardPolicy и DiscardOldestPolicy. 

По умолчанию применяется политика абортирования (abort), при которой метод execute выдает непроверяемое 
исключение RejectedExecutionException. Вызывающий элемент кода может отловить это исключение и 
реализовать обработку переполнения по своему усмотрению. Политика отбрасывания (discard) молчаливо 
отбрасывает только что предоставленную задачу, если ее нельзя поставить в очередь на выполнение. 
Политика отбрасывания самой старой задачи (discard-oldest) отбрасывает задачу, которая в иных случаях 
была бы выполнена позднее, и пытается повторно предоставить новую задачу. (Если рабочая очередь имеет 
приоритеты, то отбрасывается элемент с наивысшим приоритетом, что противоречит функциям очереди.)

Политика под управлением вызывающего элемента кода (caller-runs policy) старается замедлить поток новых 
задач, направляя некоторую работу назад вызывающему элементу кода. Она выполняет только что 
предоставленную задачу не в пуле, а в потоке, который вызывает метод execute. Если бы мы изменяли пример 
WebServer так, чтобы он использовал ограниченную очередь и политику под управлением вызывающего элемента 
кода, то в конце концов все потоки пула были бы заняты, и рабочая очередь, заполненная до конца 
следующей задачей, выполнялась бы во время вызова метода execute в главном потоке. Некоторое время 
главный поток не смог бы предоставлять задачи, давая рабочим потокам шанс нивелировать отставание, и не 
вызвал бы метод accept в это время. Поэтому входящие запросы стали бы накапливаться в очереди на уровне 
TCP, а не в приложении. При длительной перегрузке TCP тоже начал бы отбрасывать запросы, на этот раз — 
клиенту и с более плавной деградацией.

Создание пула потоков фиксированного размера с ограниченной очередью и политикой насыщения под 
управлением вызывающего элемента кода

```java
ThreadPoolExecutor executor = new ThreadPoolExecutor(N_THREADS, N_THREADS, 0L, TimeUnit.MILLISECONDS,
    new LinkedBlockingQueue<Runnable>(CAPACITY));
executor.setRejectedExecutionHandler(new ThreadPoolExecutor.CallerRunsPolicy());
```

### 8.3.4. Фабрики потоков

Пул создает потоки посредством фабрики потоков, которая по умолчанию создает поток, не являющийся 
демоном, без специальной конфигурации. Кастомизация фабрики потоков позволяет настроить конфигурацию 
потоков пула. Фабрика ThreadFactory имеет единственный метод, newThread, который вызывается всякий раз, 
когда пулу необходимо создать новый поток.

Интерфейс ThreadFactory

```java
public interface ThreadFactory {
    Thread newThread(Runnable r);
}
```

Настраиваемая фабрика потоков

```java
public class MyThreadFactory implements ThreadFactory {
    private final String poolName;
    public MyThreadFactory(String poolName) {
        this.poolName = poolName;
    }
    public Thread newThread(Runnable runnable) {
        return new MyAppThread(runnable, poolName);
    }
}
```

Базовый класс настраиваемого потока

```java
public class MyAppThread extends Thread {
    public static final String DEFAULT_NAME = "MyAppThread";
    private static volatile boolean debugLifecycle = false;
    private static final AtomicInteger created = new AtomicInteger();
    private static final AtomicInteger alive = new AtomicInteger();
    private static final Logger log = Logger.getAnonymousLogger();
    public MyAppThread(Runnable r) { this(r, DEFAULT_NAME); }
    public MyAppThread(Runnable runnable, String name) {
        super(runnable, name + "-" + created.incrementAndGet());
        setUncaughtExceptionHandler(new Thread.UncaughtExceptionHandler() {
            public void uncaughtException(Thread t,Throwable e) {
                log.log(Level.SEVERE, "НЕ ОТЛОВЛЕН в потоке " + t.getName(), e);
            }
        });
    }
    public void run() {
        // Отладочный флажок копирования для повсеместного
        // обеспечения непротиворечивого значения.
        boolean debug = debugLifecycle;
        if (debug) log.log(Level.FINE, "Создан "+getName());
        try {
            alive.incrementAndGet();
            super.run();
        } finally {
            alive.decrementAndGet();
            if (debug) log.log(Level.FINE, "Завершаю "+getName());
        }
    }
    public static int getThreadsCreated() { return created.get(); }
    public static int getThreadsAlive() { return alive.get(); }
    public static boolean getDebug() { return debugLifecycle; }
    public static void setDebug(boolean b) { debugLifecycle = b; }
}
```

(???) Если ваше приложение пользуется преимуществом политик безопасности, используйте фабричный метод
privilegedThreadFactory в исполнителях для создания фабрики потоков. Он создает потоки в пуле, которые
имеют те же разрешения, AccessControlContext и contextClassLoader, что и поток, создающий фабрику
privilegedThreadFactory. Помните, что потоки, созданные пулом, наследуют разрешения от любого клиента,
который будет вызывать методы execute или submit, что может привести к исключениям, связанным с
безопасностью.

### 8.3.5. Настройка класса ThreadPoolExecutor после конструирования

Большинство параметров, передаваемых конструкторам класса ThreadPoolExecutor, могут быть изменены после 
конструирования посредством методов доступа set. Если Executor создается с помощью одного из фабричных 
методов в классах Executor (кроме класса newSingleThreadExecutor), то для обращения к методам доступа set
вы можете привести результат к типу ThreadPoolExecutor.

Изменение исполнителя, созданного с помощью стандартных фабрик

```java
ExecutorService exec = Executors.newCachedThreadPool();
if (exec instanceof ThreadPoolExecutor)
    ((ThreadPoolExecutor) exec).setCorePoolSize(10);
else
    throw new AssertionError("Опаньки! Плохое допущение");
```

## 8.4. Расширение класса ThreadPoolExecutor

Класс ThreadPoolExecutor был спроектирован для расширения с помощью перехватчиков — методов 
beforeExecute, afterExecute и terminate. Перехватчики beforeExecute и afterExecute вызываются в потоке, 
выполняющем задачу, и используются для добавления журналирования, хронометрирования, мониторинга или 
сбора статистики. Перехватчик afterExecute вызывается независимо от того, как задача завершается: 
возвращаясь из метода run нормальным образом либо выдавая исключение.  Если перехватчик beforeExecute 
выдает исключение RuntimeException, то задачи не выполняются, и перехватчик afterExecute не вызывается.

Перехватчик terminated вызывается, когда пул потоков завершает процесс выключения. Он может 
использоваться для высвобождения ресурсов, выполнения уведомлений или журналирования, а также 
финализирования сбора статистики

### 8.4.1. Пример: добавление статистики в пул потоков

Пул потоков, расширенный журналированием и хронометрированием

```java
public class TimingThreadPool extends ThreadPoolExecutor {
    private final ThreadLocal<Long> startTime = new ThreadLocal<Long>();
    private final Logger log = Logger.getLogger("TimingThreadPool");
    private final AtomicLong numTasks = new AtomicLong();
    private final AtomicLong totalTime = new AtomicLong();
    protected void beforeExecute(Thread t, Runnable r) {
        super.beforeExecute(t, r);
        log.fine(String.format("Поток %s: начало %s", t, r));
        startTime.set(System.nanoTime());
    }
    protected void afterExecute(Runnable r, Throwable t) {
        try {
            long endTime = System.nanoTime();
            long taskTime = endTime - startTime.get();
            numTasks.incrementAndGet();
            totalTime.addAndGet(taskTime);
            log.fine(String.format("Поток %s: конец %s, время=%dns",
                    t, r, taskTime));
        } finally {
            super.afterExecute(r, t);
        }
    }
    protected void terminated() {
        try {
            log.info(String.format("Terminated: avg time=%dns",
                    totalTime.get() / numTasks.get()));
        } finally {
            super.terminated();
        }
    }
}
```

## 8.5. Параллелизация рекурсивных алгоритмов

Преобразование последовательной хвостовой рекурсии в параллелизованную рекурсию

```java
public<T> void sequentialRecursive(List<Node<T>> nodes,
                                   Collection<T> results) {
    for (Node<T> n : nodes) {
        results.add(n.compute());
        sequentialRecursive(n.getChildren(), results);
    }
}
public<T> void parallelRecursive(final Executor exec,
                                 List<Node<T>> nodes,
                                 final Collection<T> results) {
    for (final Node<T> n : nodes) {
        exec.execute(new Runnable() {
            public void run() {
                results.add(n.compute());
            }
        });
        parallelRecursive(exec, n.getChildren(), results);
    }
}
```

Когда parallelRecursive возвращается, это значит, что каждый узел в дереве был посещен (обход по-
прежнему является последовательным: только вызовы метода compute выполняются параллельно), и вычисление 
для каждого узла было поставлено в очередь в исполнителе. Элементы кода, вызывающие метод 
parallelRecursive, могут ожидать все результаты, создав специфичный для обхода исполнитель и используя 
методы shutdown и awaitTermination

Ожидание результатов, которые будут вычислены параллельно

```java
public<T> Collection<T> getParallelResults(List<Node<T>> nodes)
        throws InterruptedException {
    ExecutorService exec = Executors.newCachedThreadPool();
    Queue<T> resultQueue = new ConcurrentLinkedQueue<T>();
    parallelRecursive(exec, nodes, resultQueue);
    exec.shutdown();
    exec.awaitTermination(Long.MAX_VALUE, TimeUnit.SECONDS);
    return resultQueue;
}
```

### 8.5.1. Пример: фреймворк головоломки

Мы определяем головоломку как комбинацию начальной и целевой позиций и правил, определяющих допустимые 
ходы. Множество правил состоит из двух частей: вычисление списка законных ходов из заданной позиции и 
вычисление результата применения хода к позиции. Ниже показана абстракция головоломки. Параметры типа P и M 
представляют классы для позиции и хода. Из этого интерфейса мы можем написать простой последовательный 
решатель, который выполняет поиск в пространстве головоломки, до тех пор пока не будет найдено решение либо 
пространство головоломки не будет исчерпано.

Абстракция для головоломок, таких как «Скользящие блоки»

```java
public interface Puzzle<P, M> {
    P initialPosition();
    boolean isGoal(P position);
    Set<M> legalMoves(P position);
    P move(P position, M move);
}
```

Конкурентная версия решателя головоломок

```java
public class ConcurrentPuzzleSolver<P, M> {
    private final Puzzle<P, M> puzzle;
    private final ExecutorService exec;
    private final ConcurrentMap<P, Boolean> seen;
    final ValueLatch<Node<P, M>> solution = new ValueLatch<Node<P, M>>();
    ...
    public List<M> solve() throws InterruptedException {
        try {
            P p = puzzle.initialPosition();
            exec.execute(newTask(p, null, null));
            // блокировать до тех пор, пока решение не будет найдено
            Node<P, M> solnNode = solution.getValue();
            return (solnNode == null) ? null : solnNode.asMoveList();
        } finally {
            exec.shutdown();
        }
    }
    protected Runnable newTask(P p, M m, Node<P,M> n) {
        return new SolverTask(p, m, n);
    }
    class SolverTask extends Node<P, M> implements Runnable {
    ...
        public void run() {
            if (solution.isSet() || seen.putIfAbsent(pos, true) != null)
                return; // already solved or seen this position
            if (puzzle.isGoal(pos))
                solution.setValue(this);
            else
                for (M m : puzzle.legalMoves(pos))
                    exec.execute(newTask(puzzle.move(pos, m), m, this));
        }
    }
}
```


**Итоги**

Executor — это мощная и гибкая структура для конкурентного выполнения задач. Он предлагает ряд 
регулировочных параметров, таких как политики для создания и удаления потоков, обработки задач в очереди и 
действий с избыточными задачами, а также предоставляет несколько перехватчиков для расширения своего 
поведения. Однако, как и в большинстве мощных структур, в нем существуют комбинации параметров, которые 
плохо работают вместе: некоторые типы задач требуют специфических политик выполнения, а некоторые 
комбинации регулировочных параметров могут привести к непредвиденным результатам.



